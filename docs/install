#!/usr/bin/env bash
set -euo pipefail

# Ludolph Mac-First Installer
# Usage: curl -sSL https://ludolph.dev/install | bash
#
# This installer runs on your Mac and:
# 1. Finds your Obsidian vault
# 2. Sets up automatic backups through GitHub
# 3. Deploys Ludolph to your Raspberry Pi
# 4. Configures two-way sync between Mac and Pi
#
# Options (via environment variables):
#   LUDOLPH_DIR         Install directory (default: ~/.ludolph)
#   LUDOLPH_VERSION     Specific version to install (default: latest)
#   LUDOLPH_SKIP_SYNC   Skip vault sync setup (just install binary)

REPO="evannagle/ludolph"
LOCAL_DIR="${LUDOLPH_DIR:-$HOME/.ludolph}"
VERSION="${LUDOLPH_VERSION:-}"

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
DIM='\033[0;90m'
CYAN='\033[0;36m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m'

ok() { printf "  ${GREEN}[•ok]${NC} %s\n" "$1"; }
err() { printf "  ${RED}[•!!]${NC} %s\n" "$1"; }
warn() { printf "  ${YELLOW}[•--]${NC} %s\n" "$1"; }
info() { printf "  ${DIM}%s${NC}\n" "$1"; }
step() { printf "\n${BOLD}%s${NC}\n\n" "$1"; }
prompt_char() { printf "${CYAN}π${NC} "; }

# Ask yes/no question, default to yes
confirm() {
    local prompt="$1"
    local response
    printf "  %s ${DIM}[Y/n]${NC} " "$prompt"
    read -r response
    case "$response" in
        [nN]*) return 1 ;;
        *) return 0 ;;
    esac
}

# Ask yes/no question, default to no
confirm_no() {
    local prompt="$1"
    local response
    printf "  %s ${DIM}[y/N]${NC} " "$prompt"
    read -r response
    case "$response" in
        [yY]*) return 0 ;;
        *) return 1 ;;
    esac
}

# Prompt for input with optional default
prompt_input() {
    local label="$1"
    local default="${2:-}"
    local result

    if [ -n "$default" ]; then
        printf "  %s ${DIM}[%s]${NC}\n" "$label" "$default"
    else
        printf "  %s\n" "$label"
    fi
    prompt_char
    read -r result

    if [ -z "$result" ] && [ -n "$default" ]; then
        result="$default"
    fi
    echo "$result"
}

# Prompt for sensitive input (hidden)
prompt_secret() {
    local label="$1"
    local result

    printf "  %s\n" "$label"
    prompt_char
    read -rs result
    echo
    echo "$result"
}

# =============================================================================
# Header
# =============================================================================

echo
printf "${BOLD}Ludolph Installer${NC}\n"
info "A real brain for your second brain."
echo

# =============================================================================
# Step 1: Platform Detection
# =============================================================================

step "Checking your system"

OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
ARCH="$(uname -m)"

case "$ARCH" in
    x86_64) ARCH="x86_64" ;;
    aarch64|arm64) ARCH="aarch64" ;;
    *)
        err "Unsupported architecture: $ARCH"
        info "Supported: x86_64, aarch64/arm64"
        exit 1
        ;;
esac

# Determine if we're on Mac vs Pi
IS_MAC=false
IS_PI=false

case "$OS" in
    darwin)
        IS_MAC=true
        TARGET="${ARCH}-apple-darwin"
        ok "Running on Mac"
        ;;
    linux)
        TARGET="${ARCH}-unknown-linux-gnu"
        if [ "$ARCH" = "aarch64" ]; then
            IS_PI=true
            ok "Running on Raspberry Pi (or ARM Linux)"
        else
            ok "Running on Linux"
        fi
        ;;
    *)
        err "Unsupported OS: $OS"
        info "Supported: macOS, Linux"
        exit 1
        ;;
esac

# =============================================================================
# Step 2: Find Vault
# =============================================================================

step "Finding your vault"

# Try to auto-detect common vault locations
VAULT_PATH=""
VAULT_CANDIDATES=(
    "$HOME/Documents/Obsidian"
    "$HOME/Documents/vault"
    "$HOME/Obsidian"
    "$HOME/vault"
    "$HOME/Documents/Notes"
    "$HOME/Notes"
)

for candidate in "${VAULT_CANDIDATES[@]}"; do
    if [ -d "$candidate" ]; then
        # Check if it looks like an Obsidian vault
        if [ -d "$candidate/.obsidian" ]; then
            VAULT_PATH="$candidate"
            break
        fi
    fi
done

if [ -n "$VAULT_PATH" ]; then
    info "Found what looks like your vault:"
    echo
    printf "    ${CYAN}%s${NC}\n" "$VAULT_PATH"
    echo
    if ! confirm "Is this correct?"; then
        VAULT_PATH=""
    fi
fi

if [ -z "$VAULT_PATH" ]; then
    echo "  Where's your Obsidian vault?"
    info "(The folder with all your notes)"
    echo
    VAULT_PATH=$(prompt_input "" "$HOME/Documents/Obsidian")
fi

# Expand tilde
VAULT_PATH="${VAULT_PATH/#\~/$HOME}"

# Validate vault exists
if [ ! -d "$VAULT_PATH" ]; then
    err "Folder not found: $VAULT_PATH"
    exit 1
fi

ok "Vault: $VAULT_PATH"

# =============================================================================
# Step 3: Privacy Check (opt-in)
# =============================================================================

step "Privacy check"

echo "  Before syncing your vault to your Pi, would you like us"
echo "  to check for private information that should stay on"
echo "  this computer?"
echo
info "This looks for things like API keys, passwords, or"
info "sensitive files that probably shouldn't leave your Mac."
echo

PRIVACY_ISSUES=()
PRIVACY_FILES=()

if confirm "Check for private info?"; then
    echo
    info "Scanning for sensitive patterns..."

    # Patterns to look for
    # API keys
    API_KEY_PATTERN='(sk-[a-zA-Z0-9]{20,}|api[_-]?key\s*[:=]\s*["\047]?[a-zA-Z0-9_-]{20,})'
    # Passwords in config
    PASSWORD_PATTERN='(password|passwd|pwd)\s*[:=]\s*["\047]?[^\s"\047]{4,}'
    # Tokens
    TOKEN_PATTERN='(token|secret|credential)\s*[:=]\s*["\047]?[a-zA-Z0-9_-]{10,}'

    # Sensitive filenames
    SENSITIVE_FILES=(".env" "credentials" "secrets" ".secret" "api_key" "apikey")

    # Check for sensitive files by name
    while IFS= read -r -d '' file; do
        filename=$(basename "$file")
        filename_lower=$(echo "$filename" | tr '[:upper:]' '[:lower:]')

        for pattern in "${SENSITIVE_FILES[@]}"; do
            if [[ "$filename_lower" == *"$pattern"* ]]; then
                rel_path="${file#$VAULT_PATH/}"
                if [[ ! " ${PRIVACY_FILES[*]} " =~ " ${rel_path} " ]]; then
                    PRIVACY_FILES+=("$rel_path")
                    case "$pattern" in
                        .env) PRIVACY_ISSUES+=("$rel_path - environment file with secrets") ;;
                        credentials*) PRIVACY_ISSUES+=("$rel_path - looks like credentials") ;;
                        secrets*) PRIVACY_ISSUES+=("$rel_path - may contain secrets") ;;
                        *) PRIVACY_ISSUES+=("$rel_path - sensitive filename") ;;
                    esac
                fi
                break
            fi
        done
    done < <(find "$VAULT_PATH" -type f -name "*.md" -o -name "*.txt" -o -name "*.env*" -o -name "*.json" -o -name "*.yaml" -o -name "*.yml" -print0 2>/dev/null || true)

    # Check file contents for patterns (limit to text files under 1MB)
    while IFS= read -r -d '' file; do
        if [ -f "$file" ] && [ "$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)" -lt 1048576 ]; then
            # Check for API key pattern
            if grep -qEi "$API_KEY_PATTERN" "$file" 2>/dev/null; then
                rel_path="${file#$VAULT_PATH/}"
                if [[ ! " ${PRIVACY_FILES[*]} " =~ " ${rel_path} " ]]; then
                    PRIVACY_FILES+=("$rel_path")
                    PRIVACY_ISSUES+=("$rel_path - looks like it has API keys")
                fi
            fi
        fi
    done < <(find "$VAULT_PATH" -type f \( -name "*.md" -o -name "*.txt" -o -name "*.json" -o -name "*.yaml" -o -name "*.yml" \) -print0 2>/dev/null || true)

    if [ ${#PRIVACY_ISSUES[@]} -gt 0 ]; then
        echo
        warn "Found some things you might want to keep private:"
        echo
        for issue in "${PRIVACY_ISSUES[@]}"; do
            printf "    ${YELLOW}%s${NC}\n" "$issue"
        done
        echo

        if confirm "Exclude these from syncing?"; then
            # We'll add to .gitignore later after git is set up
            EXCLUDE_PRIVACY=true
            ok "Will exclude these files from sync"
        else
            EXCLUDE_PRIVACY=false
            ok "Will sync everything"
        fi
    else
        ok "No obvious sensitive files found"
        EXCLUDE_PRIVACY=false
    fi
else
    echo
    ok "Skipping privacy scan"
    EXCLUDE_PRIVACY=false
fi

# =============================================================================
# Step 4: Git/Sync Setup
# =============================================================================

step "Setting up sync"

echo "  To keep your vault in sync between your Mac and Pi,"
echo "  we'll set up automatic backups through GitHub."
echo
info "This also gives you version history - you can undo"
info "any changes Ludolph makes to your notes."
echo

cd "$VAULT_PATH"

# Check if already a git repo
IS_GIT_REPO=false
HAS_REMOTE=false
REMOTE_URL=""

if [ -d ".git" ]; then
    IS_GIT_REPO=true
    ok "Vault is already tracked with version history"

    # Check for remote
    REMOTE_URL=$(git remote get-url origin 2>/dev/null || true)
    if [ -n "$REMOTE_URL" ]; then
        HAS_REMOTE=true
        ok "Already backed up to: $REMOTE_URL"
    fi
fi

if $HAS_REMOTE; then
    # Already set up, just verify we can access it
    info "Verifying access to GitHub..."
    if git ls-remote origin &>/dev/null; then
        ok "GitHub access confirmed"
    else
        err "Can't access the GitHub repository"
        info "Check your SSH keys or access permissions"
        exit 1
    fi
else
    # Need to set up git/GitHub
    echo "  Let's back up your vault to GitHub."
    echo

    if ! confirm "Set up GitHub backup?"; then
        echo
        info "You can set this up manually later."
        info "Run: git init && git remote add origin <your-repo-url>"
        err "Sync setup skipped - can't proceed without it"
        exit 1
    fi

    # Initialize git if needed
    if ! $IS_GIT_REPO; then
        echo
        info "Setting up version history..."
        git init -q
        ok "Version history initialized"
    fi

    # Create default .gitignore
    GITIGNORE_CONTENT="# Obsidian workspace (changes constantly)
.obsidian/workspace.json
.obsidian/workspace-mobile.json
.obsidian/workspace.json.bak

# Trash
.trash/

# System files
.DS_Store
Thumbs.db
"

    # Add privacy exclusions if requested
    if [ "$EXCLUDE_PRIVACY" = true ] && [ ${#PRIVACY_FILES[@]} -gt 0 ]; then
        GITIGNORE_CONTENT+="
# Private files (excluded by installer)
"
        for file in "${PRIVACY_FILES[@]}"; do
            GITIGNORE_CONTENT+="$file
"
        done
    fi

    # Write .gitignore if it doesn't exist or is minimal
    if [ ! -f ".gitignore" ] || [ "$(wc -l < .gitignore)" -lt 5 ]; then
        echo "$GITIGNORE_CONTENT" > .gitignore
        ok "Created .gitignore"
    else
        # Append privacy exclusions to existing .gitignore
        if [ "$EXCLUDE_PRIVACY" = true ] && [ ${#PRIVACY_FILES[@]} -gt 0 ]; then
            echo "" >> .gitignore
            echo "# Private files (excluded by Ludolph installer)" >> .gitignore
            for file in "${PRIVACY_FILES[@]}"; do
                echo "$file" >> .gitignore
            done
            ok "Added privacy exclusions to .gitignore"
        fi
    fi

    # Try using gh CLI first
    if command -v gh &>/dev/null; then
        echo
        info "Using GitHub CLI to create repository..."

        # Get vault folder name for repo name
        VAULT_NAME=$(basename "$VAULT_PATH")
        REPO_NAME="${VAULT_NAME// /-}"
        REPO_NAME=$(echo "$REPO_NAME" | tr '[:upper:]' '[:lower:]')

        echo
        REPO_NAME=$(prompt_input "Repository name" "$REPO_NAME")

        echo
        info "Creating private repository on GitHub..."

        if gh repo create "$REPO_NAME" --private --source=. --remote=origin 2>/dev/null; then
            ok "Created private repository: $REPO_NAME"
            HAS_REMOTE=true
            REMOTE_URL=$(git remote get-url origin 2>/dev/null || true)
        else
            warn "Couldn't create repository automatically"
            info "You may need to run: gh auth login"
        fi
    fi

    # Manual setup if gh didn't work
    if ! $HAS_REMOTE; then
        echo
        echo "  Let's set up GitHub manually:"
        echo
        echo "  1. Go to ${CYAN}github.com/new${NC}"
        echo "  2. Name it something like ${CYAN}my-vault${NC}"
        echo "  3. Make sure ${BOLD}Private${NC} is selected"
        echo "  4. Click ${CYAN}Create repository${NC}"
        echo "  5. Copy the SSH URL (starts with git@github.com)"
        echo

        REMOTE_URL=$(prompt_input "Paste the URL here" "")

        if [ -z "$REMOTE_URL" ]; then
            err "No repository URL provided"
            exit 1
        fi

        git remote add origin "$REMOTE_URL" 2>/dev/null || git remote set-url origin "$REMOTE_URL"
        ok "Connected to: $REMOTE_URL"
        HAS_REMOTE=true
    fi

    # Initial commit and push
    echo
    info "Uploading your vault to GitHub..."

    git add -A
    git commit -m "Initial commit from Ludolph installer" -q 2>/dev/null || true

    # Get default branch name
    DEFAULT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")

    if git push -u origin "$DEFAULT_BRANCH" 2>/dev/null; then
        ok "Vault backed up to GitHub"
    else
        err "Couldn't push to GitHub"
        info "Check your SSH keys: ssh -T git@github.com"
        info "Or set up a personal access token"
        exit 1
    fi
fi

# =============================================================================
# Step 5: Connect to Pi
# =============================================================================

step "Connecting to your Pi"

if $IS_PI; then
    # We're running ON the Pi, skip SSH
    ok "Already on Pi - skipping remote setup"
    PI_HOST="localhost"
    PI_USER="$USER"
else
    echo "  What's your Pi's address?"
    info "(The hostname or IP you use to connect)"
    echo

    # Try to detect Pi on network
    PI_DETECTED=""
    for host in "raspberrypi.local" "pi.local"; do
        if ping -c 1 -W 1 "$host" &>/dev/null; then
            PI_DETECTED="$host"
            break
        fi
    done

    PI_HOST=$(prompt_input "" "${PI_DETECTED:-pi.local}")
    PI_USER=$(prompt_input "SSH username" "pi")

    echo
    info "Testing connection to $PI_USER@$PI_HOST..."

    if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$PI_USER@$PI_HOST" "echo connected" &>/dev/null; then
        err "Couldn't connect to $PI_USER@$PI_HOST"
        echo
        echo "  Make sure:"
        echo "    1. Your Pi is powered on and connected to the network"
        echo "    2. SSH is enabled on the Pi"
        echo "    3. You have SSH key access set up"
        echo
        echo "  To set up SSH keys, run:"
        printf "    ${CYAN}ssh-copy-id %s@%s${NC}\n" "$PI_USER" "$PI_HOST"
        echo
        echo "  If using Tailscale, make sure it's running on both devices."
        exit 1
    fi

    ok "Connected to $PI_USER@$PI_HOST"
fi

# =============================================================================
# Step 6: Deploy to Pi
# =============================================================================

step "Setting up your Pi"

# Resolve version
if [ -z "$VERSION" ]; then
    VERSION=$(curl -sSL "https://api.github.com/repos/$REPO/releases/latest" 2>/dev/null | grep '"tag_name"' | cut -d'"' -f4 || true)
    if [ -z "$VERSION" ]; then
        err "Couldn't fetch latest version"
        exit 1
    fi
fi

if $IS_PI; then
    # Local installation (on Pi)
    PI_INSTALL_DIR="$LOCAL_DIR/bin"
    PI_VAULT_PATH="$VAULT_PATH"

    mkdir -p "$PI_INSTALL_DIR"

    info "Downloading Ludolph $VERSION..."
    DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/lu-$TARGET"

    if ! curl -fsSL "$DOWNLOAD_URL" -o "$PI_INSTALL_DIR/lu" 2>/dev/null; then
        err "Download failed"
        exit 1
    fi
    chmod +x "$PI_INSTALL_DIR/lu"
    ok "Installed Ludolph"

else
    # Remote installation (from Mac to Pi)
    PI_TARGET="aarch64-unknown-linux-gnu"
    PI_DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/lu-$PI_TARGET"
    PI_INSTALL_DIR="\$HOME/.ludolph/bin"
    PI_VAULT_PATH="\$HOME/vault"

    info "Installing Ludolph on Pi..."

    ssh "$PI_USER@$PI_HOST" bash -s << REMOTE_INSTALL
set -e
mkdir -p ~/.ludolph/bin
curl -fsSL "$PI_DOWNLOAD_URL" -o ~/.ludolph/bin/lu 2>/dev/null
chmod +x ~/.ludolph/bin/lu

# Add to PATH if not already
if ! grep -q '.ludolph/bin' ~/.bashrc 2>/dev/null; then
    echo 'export PATH="\$HOME/.ludolph/bin:\$PATH"' >> ~/.bashrc
fi
if ! grep -q '.ludolph/bin' ~/.profile 2>/dev/null; then
    echo 'export PATH="\$HOME/.ludolph/bin:\$PATH"' >> ~/.profile
fi
REMOTE_INSTALL

    ok "Installed Ludolph"

    # Clone vault to Pi
    info "Syncing your vault to Pi..."

    REMOTE_URL_ESCAPED="${REMOTE_URL//\"/\\\"}"

    ssh "$PI_USER@$PI_HOST" bash -s << REMOTE_CLONE
set -e
if [ -d ~/vault ]; then
    cd ~/vault
    git pull origin 2>/dev/null || true
else
    git clone "$REMOTE_URL_ESCAPED" ~/vault 2>/dev/null
fi
REMOTE_CLONE

    ok "Synced your vault"

    # Set up sync cron job
    info "Setting up automatic sync..."

    ssh "$PI_USER@$PI_HOST" bash -s << REMOTE_CRON
set -e
# Remove any existing ludolph sync job
(crontab -l 2>/dev/null | grep -v 'ludolph vault sync' || true) | crontab -

# Add new sync job (every 5 minutes)
(crontab -l 2>/dev/null || true; echo "*/5 * * * * cd ~/vault && git pull origin 2>/dev/null # ludolph vault sync") | crontab -
REMOTE_CRON

    ok "Automatic sync enabled (every 5 minutes)"

    PI_VAULT_PATH="~/vault"
fi

# =============================================================================
# Step 7: API Credentials
# =============================================================================

step "Almost there!"

echo "  Just need two API keys to power your bot."
echo

# Telegram token
echo "  1. ${BOLD}Telegram Bot Token${NC}"
info "   Create one at t.me/BotFather (takes 2 minutes)"
echo
TELEGRAM_TOKEN=$(prompt_secret "")

if [ -z "$TELEGRAM_TOKEN" ]; then
    err "Telegram token is required"
    exit 1
fi

echo
# Telegram user ID
echo "  2. ${BOLD}Your Telegram User ID${NC}"
info "   Get it from t.me/userinfobot"
echo
TELEGRAM_USER_ID=$(prompt_input "")

if [ -z "$TELEGRAM_USER_ID" ]; then
    err "User ID is required"
    exit 1
fi

echo
# Claude API key
echo "  3. ${BOLD}Claude API Key${NC}"
info "   Get one at console.anthropic.com"
echo
CLAUDE_API_KEY=$(prompt_secret "")

if [ -z "$CLAUDE_API_KEY" ]; then
    err "Claude API key is required"
    exit 1
fi

# =============================================================================
# Step 8: Configure and Start
# =============================================================================

step "Configuring Ludolph"

# Create config
CONFIG_CONTENT="[telegram]
bot_token = \"$TELEGRAM_TOKEN\"
allowed_users = [$TELEGRAM_USER_ID]

[claude]
api_key = \"$CLAUDE_API_KEY\"
model = \"claude-sonnet-4-20250514\"

[vault]
path = \"$PI_VAULT_PATH\"
"

if $IS_PI; then
    # Local config (running directly on Pi)
    mkdir -p "$LOCAL_DIR"
    echo "$CONFIG_CONTENT" > "$LOCAL_DIR/config.toml"
    ok "Configuration saved"
else
    # Remote config
    CONFIG_ESCAPED="${CONFIG_CONTENT//\"/\\\"}"
    CONFIG_ESCAPED="${CONFIG_ESCAPED//$'\n'/\\n}"

    ssh "$PI_USER@$PI_HOST" bash -s << REMOTE_CONFIG
set -e
mkdir -p ~/.ludolph
cat > ~/.ludolph/config.toml << 'CONFIGEOF'
$CONFIG_CONTENT
CONFIGEOF
REMOTE_CONFIG

    ok "Configuration saved on Pi"

    # Also save local config for Mac-side tools
    mkdir -p "$LOCAL_DIR"
    cat > "$LOCAL_DIR/config.toml" << LOCALCONFIG
[telegram]
bot_token = "$TELEGRAM_TOKEN"
allowed_users = [$TELEGRAM_USER_ID]

[claude]
api_key = "$CLAUDE_API_KEY"
model = "claude-sonnet-4-20250514"

[vault]
path = "$VAULT_PATH"

[pi]
host = "$PI_HOST"
user = "$PI_USER"
LOCALCONFIG
fi

# Start the bot
echo
info "Starting your bot..."

if $IS_PI; then
    # Start locally
    nohup "$PI_INSTALL_DIR/lu" > "$LOCAL_DIR/ludolph.log" 2>&1 &
    sleep 2

    if pgrep -f "ludolph/bin/lu" >/dev/null; then
        ok "Bot is running"
    else
        warn "Bot may not have started - check ~/.ludolph/ludolph.log"
    fi
else
    # Start on Pi
    ssh "$PI_USER@$PI_HOST" bash -s << REMOTE_START
set -e
# Kill any existing instance
pkill -f 'ludolph/bin/lu' 2>/dev/null || true

# Start the bot
export PATH="\$HOME/.ludolph/bin:\$PATH"
nohup ~/.ludolph/bin/lu > ~/.ludolph/ludolph.log 2>&1 &

sleep 2
if pgrep -f 'ludolph/bin/lu' >/dev/null; then
    echo "started"
fi
REMOTE_START

    ok "Bot is running on Pi"
fi

# =============================================================================
# Done!
# =============================================================================

step "You're all set!"

# Get bot username from token
BOT_INFO=$(curl -s "https://api.telegram.org/bot$TELEGRAM_TOKEN/getMe" 2>/dev/null || true)
BOT_USERNAME=$(echo "$BOT_INFO" | grep -o '"username":"[^"]*"' | cut -d'"' -f4 || echo "your bot")

echo "  Open Telegram and message ${CYAN}@$BOT_USERNAME${NC}"
echo "  Your vault is ready to talk."
echo
info "Useful commands:"
if $IS_PI; then
    info "  lu          - Restart the bot"
    info "  lu status   - Check bot status"
else
    info "  ssh $PI_USER@$PI_HOST '~/.ludolph/bin/lu'  - Restart the bot"
fi
info "  git commit  - In your vault, save changes to sync"
echo
