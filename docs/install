#!/usr/bin/env bash
set -euo pipefail

# Ludolph Mac-First Installer
# Usage: curl -sSL https://ludolph.dev/install | bash

REPO="evannagle/ludolph"
LOCAL_DIR="${LUDOLPH_DIR:-$HOME/.ludolph}"
VERSION="${LUDOLPH_VERSION:-}"
SYNCTHING_VERSION="1.27.2"

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
DIM='\033[0;90m'
CYAN='\033[0;36m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m'

# Output helpers
ok() { printf "  ${GREEN}[•ok]${NC} %s\n" "$1"; }
err() { printf "  ${RED}[•!!]${NC} %s\n" "$1"; }
warn() { printf "  ${YELLOW}[•--]${NC} %s\n" "$1"; }
info() { printf "  ${DIM}%s${NC}\n" "$1"; }

# Bouncing ball spinner
SPINNER_PID=""

spinner_start() {
    local msg="$1"
    (
        local frames=("•  " " • " "  •" " • ")
        local i=0
        while true; do
            printf "\r  [%s] %s" "${frames[$i]}" "$msg"
            i=$(( (i + 1) % 4 ))
            sleep 0.2
        done
    ) &
    SPINNER_PID=$!
}

spinner_stop() {
    local status="$1"
    local msg="$2"
    [ -n "$SPINNER_PID" ] && kill "$SPINNER_PID" 2>/dev/null
    wait "$SPINNER_PID" 2>/dev/null || true
    SPINNER_PID=""
    printf "\r\033[K"
    if [ "$status" = "ok" ]; then
        ok "$msg"
    elif [ "$status" = "err" ]; then
        err "$msg"
    else
        warn "$msg"
    fi
}

# Section header
section() {
    echo
    printf "${BOLD}%s${NC}\n" "$1"
    echo
}

# Horizontal rule
rule() {
    printf "  ${DIM}────────────────────────────────────────${NC}\n"
}

# Wait for Enter
pause() {
    printf "\n  ${DIM}Press Enter to continue...${NC}"
    read -r
    echo
}

# Ask yes/no
confirm() {
    local response
    printf "  %s ${DIM}[Y/n]${NC} " "$1"
    read -r response
    case "$response" in
        [nN]*) return 1 ;;
        *) return 0 ;;
    esac
}

# Prompt for input
ask() {
    local prompt="$1"
    local default="${2:-}"
    local result

    if [ -n "$default" ]; then
        printf "  %s\n" "$prompt" >&2
        printf "  ${DIM}Default: %s${NC}\n" "$default" >&2
    else
        printf "  %s\n" "$prompt" >&2
    fi
    printf "  > " >&2
    read -r result
    echo >&2

    result="${result#"${result%%[![:space:]]*}"}"
    result="${result%"${result##*[![:space:]]}"}"

    [ -z "$result" ] && result="$default"
    printf '%s' "$result"
}

# Prompt for secret
ask_secret() {
    local prompt="$1"

    printf "  %s\n" "$prompt" >&2
    printf "  > " >&2
    read -rs result
    echo >&2

    result="${result#"${result%%[![:space:]]*}"}"
    result="${result%"${result##*[![:space:]]}"}"

    printf '%s' "$result"
}

# =============================================================================
# Welcome
# =============================================================================

clear
echo
printf "${BOLD}Ludolph Installer${NC}\n"
echo
info "A real brain for your second brain."
info "Talk to your vault, from anywhere, anytime."
echo
rule
echo
info "This installer will:"
info "  1. Find your Obsidian vault"
info "  2. Connect to your Raspberry Pi"
info "  3. Set up real-time sync with Syncthing"
info "  4. Configure the Telegram bot"
echo

if ! confirm "Ready to begin?"; then
    echo
    info "Run this installer again when you're ready."
    echo
    exit 0
fi

# =============================================================================
# Platform Detection
# =============================================================================

section "Step 1: Checking Your System"

OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
ARCH="$(uname -m)"

case "$ARCH" in
    x86_64) ARCH="x86_64" ;;
    aarch64|arm64) ARCH="aarch64" ;;
    *)
        err "Unsupported architecture: $ARCH"
        exit 1
        ;;
esac

IS_MAC=false
IS_PI=false

case "$OS" in
    darwin)
        IS_MAC=true
        TARGET="${ARCH}-apple-darwin"
        ok "macOS detected"
        ;;
    linux)
        TARGET="${ARCH}-unknown-linux-gnu"
        if [ "$ARCH" = "aarch64" ]; then
            IS_PI=true
            ok "Raspberry Pi detected"
        else
            ok "Linux detected"
        fi
        ;;
    *)
        err "Unsupported OS: $OS"
        exit 1
        ;;
esac

# =============================================================================
# Find Vault
# =============================================================================

section "Step 2: Finding Your Vault"

info "Looking for Obsidian vaults..."
echo

VAULT_PATH=""
VAULT_CANDIDATES=(
    "$HOME/Documents/Obsidian"
    "$HOME/Obsidian"
    "$HOME/Documents/vault"
    "$HOME/vault"
    "$HOME/Documents/Notes"
    "$HOME/Notes"
    "$HOME/Vaults"
)

# Check for vaults with .obsidian folder
for candidate in "${VAULT_CANDIDATES[@]}"; do
    if [ -d "$candidate/.obsidian" ]; then
        VAULT_PATH="$candidate"
        break
    fi
done

# Also check inside common parent folders
for parent in "$HOME/Vaults" "$HOME/Documents/Vaults" "$HOME/Documents/Obsidian"; do
    if [ -d "$parent" ]; then
        while IFS= read -r -d '' vault; do
            if [ -d "$vault/.obsidian" ]; then
                VAULT_PATH="${vault%/.obsidian}"
                break 2
            fi
        done < <(find "$parent" -maxdepth 2 -type d -name ".obsidian" -print0 2>/dev/null)
    fi
done

if [ -n "$VAULT_PATH" ]; then
    ok "Found vault: $VAULT_PATH"
    echo
    if ! confirm "Use this vault?"; then
        VAULT_PATH=""
    fi
fi

if [ -z "$VAULT_PATH" ]; then
    echo
    VAULT_PATH=$(ask "Enter the path to your Obsidian vault:" "$HOME/vault")
fi

VAULT_PATH="${VAULT_PATH/#\~/$HOME}"

if [ ! -d "$VAULT_PATH" ]; then
    echo
    warn "Folder does not exist: $VAULT_PATH"
    if confirm "Create it?"; then
        mkdir -p "$VAULT_PATH/.obsidian"
        ok "Created vault folder"
    else
        err "Cannot continue without a vault folder"
        exit 1
    fi
else
    ok "Vault confirmed: $VAULT_PATH"
fi

# =============================================================================
# Privacy Check
# =============================================================================

section "Step 3: Privacy Check"

info "Your vault will be synced to your Pi."
info "This step checks for files you might want to exclude."
echo

STIGNORE_ENTRIES=()

if confirm "Scan for sensitive files? (API keys, passwords, etc.)"; then
    echo
    spinner_start "Scanning for sensitive files..."

    PRIVACY_FILES=()

    # Check for sensitive filenames
    while IFS= read -r -d '' file; do
        filename=$(basename "$file" | tr '[:upper:]' '[:lower:]')
        case "$filename" in
            .env*|*credential*|*secret*|*password*|*apikey*|*api_key*)
                rel="${file#$VAULT_PATH/}"
                PRIVACY_FILES+=("$rel")
                ;;
        esac
    done < <(find "$VAULT_PATH" -type f \( -name "*.md" -o -name "*.txt" -o -name ".env*" -o -name "*.json" \) -print0 2>/dev/null || true)

    # Check file contents for API key patterns
    while IFS= read -r -d '' file; do
        if [ -f "$file" ] && [ "$(wc -c < "$file" 2>/dev/null)" -lt 1000000 ]; then
            if grep -qE 'sk-[a-zA-Z0-9]{20,}' "$file" 2>/dev/null; then
                rel="${file#$VAULT_PATH/}"
                [[ ! " ${PRIVACY_FILES[*]} " =~ " ${rel} " ]] && PRIVACY_FILES+=("$rel")
            fi
        fi
    done < <(find "$VAULT_PATH" -type f -name "*.md" -print0 2>/dev/null || true)

    if [ ${#PRIVACY_FILES[@]} -gt 0 ]; then
        spinner_stop "err" "Found ${#PRIVACY_FILES[@]} potentially sensitive file(s):"
        echo

        for f in "${PRIVACY_FILES[@]}"; do
            printf "    ${RED}• %s${NC}\n" "$f"
            if confirm "      Exclude this file?"; then
                STIGNORE_ENTRIES+=("$f")
            fi
            echo
        done

        if [ ${#STIGNORE_ENTRIES[@]} -gt 0 ]; then
            ok "Will exclude ${#STIGNORE_ENTRIES[@]} file(s) from sync"
        else
            ok "No files excluded"
        fi
    else
        spinner_stop "ok" "No sensitive files found"
    fi
else
    echo
    ok "Skipping privacy scan"
fi

# =============================================================================
# Connect to Pi
# =============================================================================

section "Step 4: Connecting to Your Pi"

if $IS_PI; then
    ok "Running on Pi - no remote connection needed"
    PI_HOST="localhost"
    PI_USER="$USER"
else
    info "Make sure your Pi is:"
    info "  - Powered on and connected to the network"
    info "  - SSH enabled"
    info "  - Accessible via Tailscale (recommended) or local network"
    echo

    PI_DETECTED=""
    for host in "pi" "raspberrypi" "pi.local" "raspberrypi.local"; do
        if ping -c 1 -W 1 "$host" &>/dev/null 2>&1; then
            PI_DETECTED="$host"
            break
        fi
    done

    PI_HOST=$(ask "Pi hostname or IP:" "${PI_DETECTED:-pi.local}")
    PI_USER=$(ask "SSH username:" "pi")

    spinner_start "Connecting to $PI_USER@$PI_HOST..."

    if ssh -o ConnectTimeout=5 -o BatchMode=yes "$PI_USER@$PI_HOST" "echo ok" &>/dev/null; then
        spinner_stop "ok" "Connected to $PI_USER@$PI_HOST"
    else
        spinner_stop "err" "Could not connect to $PI_USER@$PI_HOST"
        echo
        info "Troubleshooting:"
        info "  1. Verify Pi is on: ping $PI_HOST"
        info "  2. Set up SSH keys: ssh-copy-id $PI_USER@$PI_HOST"
        info "  3. Test manually: ssh $PI_USER@$PI_HOST"
        echo
        exit 1
    fi
fi

# =============================================================================
# Install Ludolph on Pi
# =============================================================================

section "Step 5: Installing Ludolph"

if [ -z "$VERSION" ]; then
    spinner_start "Fetching latest version..."
    VERSION=$(curl -sSL "https://api.github.com/repos/$REPO/releases/latest" 2>/dev/null | grep '"tag_name"' | cut -d'"' -f4 || true)
    if [ -z "$VERSION" ]; then
        spinner_stop "err" "Could not fetch version"
        exit 1
    fi
    spinner_stop "ok" "Version: $VERSION"
else
    ok "Version: $VERSION"
fi

PI_VAULT_PATH="\$HOME/vault"

if $IS_PI; then
    PI_INSTALL_DIR="$LOCAL_DIR/bin"
    PI_VAULT_PATH="$VAULT_PATH"

    mkdir -p "$PI_INSTALL_DIR"
    spinner_start "Downloading Ludolph..."
    DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/lu-$TARGET"
    curl -fsSL "$DOWNLOAD_URL" -o "$PI_INSTALL_DIR/lu" 2>/dev/null
    chmod +x "$PI_INSTALL_DIR/lu"
    spinner_stop "ok" "Installed lu binary"
else
    PI_TARGET="aarch64-unknown-linux-gnu"
    PI_DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/lu-$PI_TARGET"

    spinner_start "Installing Ludolph on Pi..."
    ssh "$PI_USER@$PI_HOST" bash -s <<EOF
set -e
mkdir -p ~/.ludolph/bin
curl -fsSL "$PI_DOWNLOAD_URL" -o ~/.ludolph/bin/lu 2>/dev/null
chmod +x ~/.ludolph/bin/lu
grep -q '.ludolph/bin' ~/.bashrc 2>/dev/null || echo 'export PATH="\$HOME/.ludolph/bin:\$PATH"' >> ~/.bashrc
grep -q '.ludolph/bin' ~/.profile 2>/dev/null || echo 'export PATH="\$HOME/.ludolph/bin:\$PATH"' >> ~/.profile
EOF
    spinner_stop "ok" "Installed Ludolph on Pi"
fi

# =============================================================================
# Initial Vault Copy
# =============================================================================

if ! $IS_PI; then
    section "Step 6: Copying Vault to Pi"

    # Show vault info
    VAULT_SIZE=$(du -sh "$VAULT_PATH" 2>/dev/null | cut -f1)
    FILE_COUNT=$(find "$VAULT_PATH" -type f 2>/dev/null | wc -l | tr -d ' ')
    info "Vault: $VAULT_PATH"
    info "Size: $VAULT_SIZE ($FILE_COUNT files)"
    echo

    # Check if vault is in a git repo with a remote
    cd "$VAULT_PATH"
    HAS_GIT_REMOTE=false
    GIT_REMOTE_URL=""
    IS_GIT_REPO=false

    spinner_start "Checking for version control..."
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        IS_GIT_REPO=true
        GIT_REMOTE_URL=$(git remote get-url origin 2>/dev/null || true)
        if [ -n "$GIT_REMOTE_URL" ]; then
            HAS_GIT_REMOTE=true
            spinner_stop "ok" "Found: $GIT_REMOTE_URL"
        else
            spinner_stop "ok" "Local version control (no backup)"
        fi
    else
        spinner_stop "ok" "No version control"
    fi

    # Offer to set up GitHub if no remote
    if ! $HAS_GIT_REMOTE; then
        echo
        info "Version control gives you:"
        info "  • History of every change (can undo anything)"
        info "  • Automatic backup to GitHub"
        info "  • Faster sync to Pi"
        echo

        if confirm "Set up GitHub backup for your vault?"; then
            echo

            # Check for gh CLI
            if command -v gh &>/dev/null; then
                # Check if authenticated
                if gh auth status &>/dev/null; then
                    GITHUB_USER=$(gh api user -q .login 2>/dev/null)
                    REPO_NAME=$(basename "$VAULT_PATH" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')

                    # Initialize git if needed
                    if ! $IS_GIT_REPO; then
                        spinner_start "Initializing version control..."
                        git init -q

                        # Create .gitignore
                        cat > .gitignore <<'GITIGNORE'
# Obsidian workspace (changes constantly)
.obsidian/workspace.json
.obsidian/workspace-mobile.json
.obsidian/workspace.json.bak

# Trash
.trash/

# System files
.DS_Store
GITIGNORE

                        git add -A
                        git commit -q -m "Initial commit"
                        spinner_stop "ok" "Version control initialized"
                    fi

                    # Create GitHub repo
                    spinner_start "Creating private GitHub repository..."
                    if gh repo create "$REPO_NAME" --private --source=. --push &>/dev/null; then
                        GIT_REMOTE_URL=$(git remote get-url origin 2>/dev/null)
                        HAS_GIT_REMOTE=true
                        spinner_stop "ok" "Created: github.com/$GITHUB_USER/$REPO_NAME"
                    else
                        spinner_stop "err" "Could not create repository"
                        info "You can set this up manually later."
                    fi
                else
                    warn "GitHub CLI not authenticated"
                    echo
                    info "Run: gh auth login"
                    info "Then re-run the installer."
                    echo
                    info "Continuing without GitHub backup..."
                fi
            else
                # No gh CLI - guide manual setup
                info "To set up GitHub backup manually:"
                echo
                info "  1. Go to github.com/new"
                info "  2. Name it something like 'my-vault'"
                info "  3. Select 'Private'"
                info "  4. Click 'Create repository'"
                info "  5. Follow the instructions to push existing code"
                echo
                info "Or install GitHub CLI: brew install gh"
                echo
                info "Continuing without GitHub backup..."
            fi
        else
            echo
            ok "Skipping GitHub backup"
        fi
    fi
    echo

    # Now deploy based on whether we have a remote
    if $HAS_GIT_REMOTE; then
        info "Deploying via git clone..."
        echo

        # Get the subdirectory if vault is not at repo root
        GIT_ROOT=$(git rev-parse --show-toplevel)
        if [ "$GIT_ROOT" != "$VAULT_PATH" ]; then
            VAULT_SUBDIR="${VAULT_PATH#$GIT_ROOT/}"
            PI_VAULT_PATH="~/repo/$VAULT_SUBDIR"
            info "Vault is subdirectory: $VAULT_SUBDIR"
        else
            VAULT_SUBDIR=""
            PI_VAULT_PATH="~/repo"
        fi

        # Check if repo exists on Pi
        spinner_start "git: Checking Pi for existing repo..."
        PI_HAS_REPO=$(ssh "$PI_USER@$PI_HOST" "[ -d ~/repo/.git ] && echo yes || echo no")

        if [ "$PI_HAS_REPO" = "yes" ]; then
            spinner_stop "ok" "git: Found existing repo on Pi"

            spinner_start "git: Pulling latest changes..."
            ssh "$PI_USER@$PI_HOST" "cd ~/repo && git pull origin" &>/dev/null
            spinner_stop "ok" "git: Pulled latest changes"
        else
            spinner_stop "ok" "git: No existing repo on Pi"

            spinner_start "git: Cloning $GIT_REMOTE_URL..."
            ssh "$PI_USER@$PI_HOST" "git clone '$GIT_REMOTE_URL' ~/repo" &>/dev/null
            spinner_stop "ok" "git: Repository cloned to ~/repo"
        fi
    else
        # Fall back to rsync
        info "Deploying via rsync..."
        echo
        PI_VAULT_PATH="~/vault"

        spinner_start "rsync: Creating ~/vault on Pi..."
        ssh "$PI_USER@$PI_HOST" "mkdir -p ~/vault"
        spinner_stop "ok" "rsync: Created ~/vault"

        info "rsync: Large vaults may take several minutes..."
        spinner_start "rsync: Copying $VAULT_SIZE to Pi..."
        rsync -az --delete \
            --exclude='.obsidian/workspace.json' \
            --exclude='.obsidian/workspace-mobile.json' \
            --exclude='.trash' \
            --exclude='.DS_Store' \
            "$VAULT_PATH/" "$PI_USER@$PI_HOST:~/vault/"
        spinner_stop "ok" "rsync: Copied $FILE_COUNT files to ~/vault"
    fi
fi

# =============================================================================
# Install Syncthing
# =============================================================================

section "Step 7: Setting Up Real-Time Sync"

info "Syncthing keeps your vault in sync between Mac and Pi."
info "Changes on either side sync automatically."
echo

# Install on Mac
if $IS_MAC; then
    spinner_start "Installing Syncthing on Mac..."

    if command -v brew &>/dev/null; then
        # Use Homebrew
        brew install syncthing &>/dev/null || true
        spinner_stop "ok" "Syncthing installed via Homebrew"
    else
        # Direct download
        mkdir -p "$LOCAL_DIR/bin"

        if [ "$ARCH" = "aarch64" ]; then
            ST_ARCH="arm64"
        else
            ST_ARCH="amd64"
        fi

        ST_URL="https://github.com/syncthing/syncthing/releases/download/v${SYNCTHING_VERSION}/syncthing-macos-${ST_ARCH}-v${SYNCTHING_VERSION}.zip"

        curl -fsSL "$ST_URL" -o "/tmp/syncthing.zip" 2>/dev/null
        unzip -q -o "/tmp/syncthing.zip" -d "/tmp/"
        mv "/tmp/syncthing-macos-${ST_ARCH}-v${SYNCTHING_VERSION}/syncthing" "$LOCAL_DIR/bin/"
        chmod +x "$LOCAL_DIR/bin/syncthing"
        rm -rf "/tmp/syncthing.zip" "/tmp/syncthing-macos-${ST_ARCH}-v${SYNCTHING_VERSION}"

        spinner_stop "ok" "Syncthing installed to ~/.ludolph/bin"
    fi
fi

# Install on Pi
if ! $IS_PI; then
    spinner_start "Installing Syncthing on Pi..."
    ssh "$PI_USER@$PI_HOST" bash -s <<'EOF'
set -e
if ! command -v syncthing &>/dev/null; then
    sudo apt-get update -qq
    sudo apt-get install -y -qq syncthing >/dev/null 2>&1
fi
EOF
    spinner_stop "ok" "Syncthing installed on Pi"
fi

# =============================================================================
# Configure Syncthing
# =============================================================================

spinner_start "Configuring Syncthing..."

# Generate config and get device IDs
if $IS_MAC; then
    # Mac: Generate config if needed
    if [ ! -d "$HOME/.config/syncthing" ]; then
        if command -v syncthing &>/dev/null; then
            syncthing generate --config="$HOME/.config/syncthing" &>/dev/null
        else
            "$LOCAL_DIR/bin/syncthing" generate --config="$HOME/.config/syncthing" &>/dev/null
        fi
    fi

    if command -v syncthing &>/dev/null; then
        MAC_DEVICE_ID=$(syncthing --device-id 2>/dev/null)
    else
        MAC_DEVICE_ID=$("$LOCAL_DIR/bin/syncthing" --device-id 2>/dev/null)
    fi
fi

if ! $IS_PI; then
    # Pi: Generate config and get device ID
    PI_DEVICE_ID=$(ssh "$PI_USER@$PI_HOST" bash -s <<'EOF'
if [ ! -d "$HOME/.config/syncthing" ]; then
    syncthing generate --config="$HOME/.config/syncthing" &>/dev/null
fi
syncthing --device-id 2>/dev/null
EOF
)
fi

spinner_stop "ok" "Generated Syncthing configs"

# Configure the shared folder and devices
spinner_start "Configuring sync folder..."

if $IS_MAC; then
    # Create .stignore file for excluded files
    STIGNORE_FILE="$VAULT_PATH/.stignore"
    cat > "$STIGNORE_FILE" <<'STIGNORE'
// Syncthing ignore patterns for Ludolph
.obsidian/workspace.json
.obsidian/workspace-mobile.json
.obsidian/workspace.json.bak
.trash
.DS_Store
STIGNORE

    # Add user-excluded files
    if [ ${#STIGNORE_ENTRIES[@]} -gt 0 ]; then
        echo "" >> "$STIGNORE_FILE"
        echo "// Files excluded by Ludolph installer" >> "$STIGNORE_FILE"
        for entry in "${STIGNORE_ENTRIES[@]}"; do
            echo "$entry" >> "$STIGNORE_FILE"
        done
    fi
fi

# Copy .stignore to Pi (use correct vault path)
if ! $IS_PI && [ -f "$VAULT_PATH/.stignore" ]; then
    scp -q "$VAULT_PATH/.stignore" "$PI_USER@$PI_HOST:$PI_VAULT_PATH/.stignore"
fi

spinner_stop "ok" "Sync folder configured"

# Add devices and folder to Syncthing config
spinner_start "Linking Mac and Pi..."

if $IS_MAC && ! $IS_PI; then
    # Configure Mac's Syncthing
    ST_CONFIG="$HOME/.config/syncthing/config.xml"

    # Use Python to modify XML config (available on Mac by default)
    python3 - "$ST_CONFIG" "$PI_DEVICE_ID" "$VAULT_PATH" <<'PYEOF'
import sys
import xml.etree.ElementTree as ET

config_file = sys.argv[1]
pi_device_id = sys.argv[2]
vault_path = sys.argv[3]

tree = ET.parse(config_file)
root = tree.getroot()

# Add Pi as a device if not present
devices = root.findall('.//device')
pi_exists = any(d.get('id') == pi_device_id for d in devices)
if not pi_exists:
    device = ET.SubElement(root, 'device')
    device.set('id', pi_device_id)
    device.set('name', 'Pi')
    device.set('compression', 'metadata')
    device.set('introducer', 'false')
    device.set('skipIntroductionRemovals', 'false')
    device.set('introducedBy', '')
    ET.SubElement(device, 'address').text = 'dynamic'
    ET.SubElement(device, 'autoAcceptFolders').text = 'true'

# Add vault folder if not present
folders = root.findall('.//folder')
vault_exists = any(f.get('path') == vault_path for f in folders)
if not vault_exists:
    folder = ET.SubElement(root, 'folder')
    folder.set('id', 'ludolph-vault')
    folder.set('label', 'Ludolph Vault')
    folder.set('path', vault_path)
    folder.set('type', 'sendreceive')
    folder.set('rescanIntervalS', '60')
    folder.set('fsWatcherEnabled', 'true')
    folder.set('fsWatcherDelayS', '1')
    folder.set('ignorePerms', 'false')
    folder.set('autoNormalize', 'true')

    # Share with Pi
    dev_elem = ET.SubElement(folder, 'device')
    dev_elem.set('id', pi_device_id)
    dev_elem.set('introducedBy', '')

tree.write(config_file)
PYEOF

    # Configure Pi's Syncthing (pass vault path as argument)
    # Note: PI_VAULT_PATH uses ~ which expands on Pi via os.path.expanduser
    ssh "$PI_USER@$PI_HOST" python3 - "$MAC_DEVICE_ID" "$PI_VAULT_PATH" <<'PYEOF'
import sys
import xml.etree.ElementTree as ET
import os

config_file = os.path.expanduser('~/.config/syncthing/config.xml')
mac_device_id = sys.argv[1]
vault_path = os.path.expanduser(sys.argv[2])

tree = ET.parse(config_file)
root = tree.getroot()

# Add Mac as a device if not present
devices = root.findall('.//device')
mac_exists = any(d.get('id') == mac_device_id for d in devices)
if not mac_exists:
    device = ET.SubElement(root, 'device')
    device.set('id', mac_device_id)
    device.set('name', 'Mac')
    device.set('compression', 'metadata')
    device.set('introducer', 'false')
    device.set('skipIntroductionRemovals', 'false')
    device.set('introducedBy', '')
    ET.SubElement(device, 'address').text = 'dynamic'
    ET.SubElement(device, 'autoAcceptFolders').text = 'true'

# Add vault folder if not present
folders = root.findall('.//folder')
vault_exists = any(f.get('path') == vault_path for f in folders)
if not vault_exists:
    folder = ET.SubElement(root, 'folder')
    folder.set('id', 'ludolph-vault')
    folder.set('label', 'Ludolph Vault')
    folder.set('path', vault_path)
    folder.set('type', 'sendreceive')
    folder.set('rescanIntervalS', '60')
    folder.set('fsWatcherEnabled', 'true')
    folder.set('fsWatcherDelayS', '1')
    folder.set('ignorePerms', 'false')
    folder.set('autoNormalize', 'true')

    # Share with Mac
    dev_elem = ET.SubElement(folder, 'device')
    dev_elem.set('id', mac_device_id)
    dev_elem.set('introducedBy', '')

tree.write(config_file)
PYEOF
fi

spinner_stop "ok" "Mac and Pi linked"

# Start Syncthing services
spinner_start "Starting Syncthing..."

if $IS_MAC; then
    # Start Syncthing on Mac (in background)
    if command -v brew &>/dev/null; then
        brew services start syncthing &>/dev/null || true
    else
        nohup "$LOCAL_DIR/bin/syncthing" --no-browser > "$LOCAL_DIR/syncthing.log" 2>&1 &
    fi
fi

if ! $IS_PI; then
    # Enable and start Syncthing on Pi
    ssh "$PI_USER@$PI_HOST" bash -s <<'EOF'
systemctl --user enable syncthing.service 2>/dev/null || true
systemctl --user start syncthing.service 2>/dev/null || true
EOF
fi

spinner_stop "ok" "Syncthing running on both devices"

# =============================================================================
# API Credentials
# =============================================================================

section "Step 8: API Keys"

info "Ludolph needs two API keys to work:"
echo
info "  1. Telegram Bot Token - creates your bot"
info "     Get one from @BotFather: t.me/BotFather"
echo
info "  2. Claude API Key - powers the AI"
info "     Get one from: console.anthropic.com"
echo

pause

TELEGRAM_TOKEN=$(ask_secret "Telegram Bot Token:")
[ -z "$TELEGRAM_TOKEN" ] && { err "Token required"; exit 1; }

echo
TELEGRAM_USER_ID=$(ask "Your Telegram User ID (get from @userinfobot):")
[ -z "$TELEGRAM_USER_ID" ] && { err "User ID required"; exit 1; }

echo
CLAUDE_API_KEY=$(ask_secret "Claude API Key:")
[ -z "$CLAUDE_API_KEY" ] && { err "API key required"; exit 1; }

# =============================================================================
# Configure and Start Bot
# =============================================================================

section "Step 9: Starting Ludolph"

CONFIG="[telegram]
bot_token = \"$TELEGRAM_TOKEN\"
allowed_users = [$TELEGRAM_USER_ID]

[claude]
api_key = \"$CLAUDE_API_KEY\"
model = \"claude-sonnet-4-20250514\"

[vault]
path = \"$PI_VAULT_PATH\"
"

if $IS_PI; then
    spinner_start "Saving configuration..."
    mkdir -p "$LOCAL_DIR"
    echo "$CONFIG" > "$LOCAL_DIR/config.toml"
    spinner_stop "ok" "Configuration saved"

    spinner_start "Starting bot..."
    nohup "$LOCAL_DIR/bin/lu" > "$LOCAL_DIR/ludolph.log" 2>&1 &
    sleep 2
    if pgrep -f 'ludolph/bin/lu' >/dev/null; then
        spinner_stop "ok" "Bot is running"
    else
        spinner_stop "warn" "Check ~/.ludolph/ludolph.log"
    fi
else
    spinner_start "Saving configuration..."
    ssh "$PI_USER@$PI_HOST" bash -s <<EOF
mkdir -p ~/.ludolph
cat > ~/.ludolph/config.toml << 'CONFIGEOF'
$CONFIG
CONFIGEOF
EOF
    mkdir -p "$LOCAL_DIR"
    cat > "$LOCAL_DIR/config.toml" <<EOF
[telegram]
bot_token = "$TELEGRAM_TOKEN"
allowed_users = [$TELEGRAM_USER_ID]

[claude]
api_key = "$CLAUDE_API_KEY"
model = "claude-sonnet-4-20250514"

[vault]
path = "$VAULT_PATH"

[pi]
host = "$PI_HOST"
user = "$PI_USER"
EOF
    spinner_stop "ok" "Configuration saved"

    spinner_start "Starting bot on Pi..."
    BOT_STARTED=$(ssh "$PI_USER@$PI_HOST" bash -s <<'EOF'
pkill -f 'ludolph/bin/lu' 2>/dev/null || true
export PATH="$HOME/.ludolph/bin:$PATH"
nohup ~/.ludolph/bin/lu > ~/.ludolph/ludolph.log 2>&1 &
sleep 2
pgrep -f 'ludolph/bin/lu' >/dev/null && echo "running"
EOF
)
    if [ "$BOT_STARTED" = "running" ]; then
        spinner_stop "ok" "Bot is running"
    else
        spinner_stop "warn" "Bot may not have started"
    fi
fi

# =============================================================================
# Done
# =============================================================================

section "Setup Complete!"

BOT_INFO=$(curl -s "https://api.telegram.org/bot$TELEGRAM_TOKEN/getMe" 2>/dev/null || true)
BOT_USERNAME=$(echo "$BOT_INFO" | grep -o '"username":"[^"]*"' | cut -d'"' -f4 || echo "your bot")

echo
printf "  Open Telegram and message ${CYAN}@%s${NC}\n" "$BOT_USERNAME"
echo
info "Your vault is ready to talk."
info "Changes sync automatically between Mac and Pi."
echo
rule
echo
info "Helpful commands:"
if $IS_PI; then
    info "  lu          Start the bot"
    info "  lu status   Check bot status"
else
    info "  ssh $PI_USER@$PI_HOST   Connect to your Pi"
fi
echo
