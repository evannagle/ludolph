#!/usr/bin/env bash
set -euo pipefail

# Ludolph Installer - Thin Pi + Mac MCP Architecture
# Usage: curl -sSL https://ludolph.dev/install | bash
#
# Pi is a thin client. Mac hosts the MCP server. No vault sync.

REPO="evannagle/ludolph"
LOCAL_DIR="${LUDOLPH_DIR:-$HOME/.ludolph}"
VERSION="${LUDOLPH_VERSION:-}"

# Clean exit on Ctrl+C
cleanup() {
    [ -n "${SPINNER_PID:-}" ] && kill "$SPINNER_PID" 2>/dev/null
    printf "\r\033[K"
    echo
    echo "  Cancelled."
    echo
    exit 1
}
trap cleanup INT TERM

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
DIM='\033[0;90m'
CYAN='\033[0;36m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m'

# Output helpers
ok() { printf "  ${GREEN}[•ok]${NC} %s\n" "$1"; }
err() { printf "  ${RED}[•!!]${NC} %s\n" "$1"; }
warn() { printf "  ${YELLOW}[•--]${NC} %s\n" "$1"; }
info() { printf "  ${DIM}%s${NC}\n" "$1"; }

# Bouncing ball spinner
SPINNER_PID=""

spinner_start() {
    local msg="$1"
    (
        local frames=("•  " " • " "  •" " • ")
        local i=0
        while true; do
            printf "\r  [%s] %s" "${frames[$i]}" "$msg"
            i=$(( (i + 1) % 4 ))
            sleep 0.2
        done
    ) &
    SPINNER_PID=$!
}

spinner_stop() {
    local status="$1"
    local msg="$2"
    [ -n "$SPINNER_PID" ] && kill "$SPINNER_PID" 2>/dev/null
    wait "$SPINNER_PID" 2>/dev/null || true
    SPINNER_PID=""
    printf "\r\033[K"
    if [ "$status" = "ok" ]; then
        ok "$msg"
    elif [ "$status" = "err" ]; then
        err "$msg"
    else
        warn "$msg"
    fi
}

# Section header
section() {
    echo
    printf "${BOLD}%s${NC}\n" "$1"
    echo
}

# Horizontal rule
rule() {
    printf "  ${DIM}────────────────────────────────────────${NC}\n"
}

# Wait for Enter
pause() {
    printf "\n  ${DIM}Press Enter to continue...${NC}"
    read -r < /dev/tty
    echo
}

# Ask yes/no
confirm() {
    local response
    printf "  %s ${DIM}[Y/n]${NC} " "$1"
    read -r response < /dev/tty
    case "$response" in
        [nN]*) return 1 ;;
        *) return 0 ;;
    esac
}

# Prompt for input
ask() {
    local prompt="$1"
    local default="${2:-}"
    local result

    if [ -n "$default" ]; then
        printf "  %s\n" "$prompt" >&2
        printf "  ${DIM}Default: %s${NC}\n" "$default" >&2
    else
        printf "  %s\n" "$prompt" >&2
    fi
    printf "  > " >&2
    read -r result < /dev/tty
    echo >&2

    result="${result#"${result%%[![:space:]]*}"}"
    result="${result%"${result##*[![:space:]]}"}"

    [ -z "$result" ] && result="$default"
    printf '%s' "$result"
}

# Prompt for secret
ask_secret() {
    local prompt="$1"

    printf "  %s\n" "$prompt" >&2
    printf "  > " >&2
    read -rs result < /dev/tty
    echo >&2

    result="${result#"${result%%[![:space:]]*}"}"
    result="${result%"${result##*[![:space:]]}"}"

    printf '%s' "$result"
}

# =============================================================================
# Welcome
# =============================================================================

clear
echo
printf "${BOLD}Ludolph Installer${NC}\n"
echo
info "A real brain for your second brain."
info "Talk to your vault, from anywhere, anytime."
echo
rule
echo
info "This installer will:"
info "  1. Find your Obsidian vault"
info "  2. Connect to your Raspberry Pi"
info "  3. Set up a server on your Mac to share your vault"
info "  4. Configure Wake-on-LAN (so Pi can wake your Mac)"
info "  5. Configure the Telegram bot"
info "  6. Start everything"
echo
info "Your vault stays on your Mac. The Pi asks your Mac"
info "for notes when you send messages in Telegram."
echo

if ! confirm "Ready to begin?"; then
    echo
    info "Run this installer again when you're ready."
    echo
    exit 0
fi

# =============================================================================
# Load Existing Config (for re-runs)
# =============================================================================

SAVED_VAULT=""
SAVED_PI_HOST=""
SAVED_PI_USER=""
SAVED_TELEGRAM_TOKEN=""
SAVED_TELEGRAM_USER=""
SAVED_CLAUDE_KEY=""

if [ -f "$LOCAL_DIR/config.toml" ]; then
    # Extract values from TOML (handles both Mac and Linux sed)
    SAVED_VAULT=$(grep '^path' "$LOCAL_DIR/config.toml" 2>/dev/null | head -1 | cut -d'"' -f2)
    SAVED_PI_HOST=$(grep '^host' "$LOCAL_DIR/config.toml" 2>/dev/null | head -1 | cut -d'"' -f2)
    SAVED_PI_USER=$(grep '^user' "$LOCAL_DIR/config.toml" 2>/dev/null | head -1 | cut -d'"' -f2)
    SAVED_TELEGRAM_TOKEN=$(grep '^bot_token' "$LOCAL_DIR/config.toml" 2>/dev/null | head -1 | cut -d'"' -f2)
    SAVED_TELEGRAM_USER=$(grep '^allowed_users' "$LOCAL_DIR/config.toml" 2>/dev/null | head -1 | tr -d '[]' | cut -d'=' -f2 | tr -d ' ')
    SAVED_CLAUDE_KEY=$(grep '^api_key' "$LOCAL_DIR/config.toml" 2>/dev/null | head -1 | cut -d'"' -f2)
fi

# =============================================================================
# Platform Detection
# =============================================================================

section "Step 1: Checking Your System"

OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
ARCH="$(uname -m)"

case "$ARCH" in
    x86_64) ARCH="x86_64" ;;
    aarch64|arm64) ARCH="aarch64" ;;
    *)
        err "Unsupported architecture: $ARCH"
        exit 1
        ;;
esac

IS_MAC=false
IS_PI=false

case "$OS" in
    darwin)
        IS_MAC=true
        TARGET="${ARCH}-apple-darwin"
        ok "macOS detected"
        ;;
    linux)
        TARGET="${ARCH}-unknown-linux-gnu"
        if [ "$ARCH" = "aarch64" ]; then
            IS_PI=true
            ok "Raspberry Pi detected"
        else
            ok "Linux detected"
        fi
        ;;
    *)
        err "Unsupported OS: $OS"
        exit 1
        ;;
esac

# =============================================================================
# Find Vault
# =============================================================================

section "Step 2: Finding Your Vault"

info "Looking for Obsidian vaults..."
echo

VAULT_PATH=""

# Check for previously configured vault
if [ -n "$SAVED_VAULT" ] && [ -d "$SAVED_VAULT" ]; then
    ok "Found previous vault: $SAVED_VAULT"
    echo
    if confirm "Use this vault?"; then
        VAULT_PATH="$SAVED_VAULT"
    fi
fi

# Only search for vaults if we don't have one yet
if [ -z "$VAULT_PATH" ]; then
    VAULT_CANDIDATES=(
        "$HOME/Documents/Obsidian"
        "$HOME/Obsidian"
        "$HOME/Documents/vault"
        "$HOME/vault"
        "$HOME/Documents/Notes"
        "$HOME/Notes"
        "$HOME/Vaults"
    )

    # Check for vaults with .obsidian folder
    for candidate in "${VAULT_CANDIDATES[@]}"; do
        if [ -d "$candidate/.obsidian" ]; then
            VAULT_PATH="$candidate"
            break
        fi
    done
fi

# Also check inside common parent folders
if [ -z "$VAULT_PATH" ]; then
    for parent in "$HOME/Vaults" "$HOME/Documents/Vaults" "$HOME/Documents/Obsidian"; do
        if [ -d "$parent" ]; then
            while IFS= read -r -d '' vault; do
                if [ -d "$vault/.obsidian" ]; then
                    VAULT_PATH="${vault%/.obsidian}"
                    break 2
                fi
            done < <(find "$parent" -maxdepth 2 -type d -name ".obsidian" -print0 2>/dev/null)
        fi
    done

    if [ -n "$VAULT_PATH" ]; then
        ok "Found vault: $VAULT_PATH"
        echo
        if ! confirm "Use this vault?"; then
            VAULT_PATH=""
        fi
    fi
fi

if [ -z "$VAULT_PATH" ]; then
    echo
    VAULT_PATH=$(ask "Enter the path to your Obsidian vault:" "$HOME/vault")
fi

VAULT_PATH="${VAULT_PATH/#\~/$HOME}"

if [ ! -d "$VAULT_PATH" ]; then
    echo
    warn "Folder does not exist: $VAULT_PATH"
    if confirm "Create it?"; then
        mkdir -p "$VAULT_PATH/.obsidian"
        ok "Created vault folder"
    else
        err "Cannot continue without a vault folder"
        exit 1
    fi
else
    ok "Vault confirmed: $VAULT_PATH"
fi

# =============================================================================
# Connect to Pi
# =============================================================================

section "Step 3: Connecting to Your Pi"

if $IS_PI; then
    ok "Running on Pi - no remote connection needed"
    PI_HOST="localhost"
    PI_USER="$USER"
else
    info "Make sure your Pi is:"
    info "  - Powered on and connected to the network"
    info "  - SSH enabled"
    info "  - Accessible via Tailscale (recommended) or local network"
    echo

    # Use saved values or detect
    PI_DEFAULT="${SAVED_PI_HOST:-}"
    if [ -z "$PI_DEFAULT" ]; then
        for host in "pi" "raspberrypi" "pi.local" "raspberrypi.local"; do
            if ping -c 1 -W 1 "$host" &>/dev/null 2>&1; then
                PI_DEFAULT="$host"
                break
            fi
        done
    fi

    PI_HOST=$(ask "Pi hostname or IP:" "${PI_DEFAULT:-pi.local}")
    PI_USER=$(ask "SSH username:" "${SAVED_PI_USER:-pi}")

    spinner_start "Connecting to $PI_USER@$PI_HOST..."

    if ssh -n -o ConnectTimeout=5 -o BatchMode=yes "$PI_USER@$PI_HOST" "echo ok" &>/dev/null; then
        spinner_stop "ok" "Connected to $PI_USER@$PI_HOST"
    else
        spinner_stop "err" "Could not connect to $PI_USER@$PI_HOST"
        echo
        info "Troubleshooting:"
        info "  1. Verify Pi is on: ping $PI_HOST"
        info "  2. Set up SSH keys: ssh-copy-id $PI_USER@$PI_HOST"
        info "  3. Test manually: ssh $PI_USER@$PI_HOST"
        echo
        exit 1
    fi
fi

# =============================================================================
# Install Ludolph on Pi
# =============================================================================

section "Step 4: Installing Ludolph"

if [ -z "$VERSION" ]; then
    spinner_start "Fetching latest version..."
    VERSION=$(curl -sSL "https://api.github.com/repos/$REPO/releases/latest" 2>/dev/null | grep '"tag_name"' | cut -d'"' -f4 || true)
    if [ -z "$VERSION" ]; then
        spinner_stop "err" "Could not fetch version"
        exit 1
    fi
    spinner_stop "ok" "Version: $VERSION"
else
    ok "Version: $VERSION"
fi

PI_VAULT_PATH="\$HOME/vault"

if $IS_PI; then
    PI_INSTALL_DIR="$LOCAL_DIR/bin"
    PI_VAULT_PATH="$VAULT_PATH"

    mkdir -p "$PI_INSTALL_DIR"
    spinner_start "Downloading Ludolph..."
    DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/lu-$TARGET"
    curl -fsSL "$DOWNLOAD_URL" -o "$PI_INSTALL_DIR/lu" 2>/dev/null
    chmod +x "$PI_INSTALL_DIR/lu"
    spinner_stop "ok" "Installed lu binary"
else
    PI_TARGET="aarch64-unknown-linux-gnu"
    PI_DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/lu-$PI_TARGET"

    spinner_start "Installing Ludolph on Pi..."
    ssh -T "$PI_USER@$PI_HOST" "
mkdir -p ~/.ludolph/bin &&
curl -fsSL '$PI_DOWNLOAD_URL' -o ~/.ludolph/bin/lu 2>/dev/null &&
chmod +x ~/.ludolph/bin/lu &&
(grep -q '.ludolph/bin' ~/.bashrc 2>/dev/null || echo 'export PATH=\"\$HOME/.ludolph/bin:\$PATH\"' >> ~/.bashrc) &&
(grep -q '.ludolph/bin' ~/.profile 2>/dev/null || echo 'export PATH=\"\$HOME/.ludolph/bin:\$PATH\"' >> ~/.profile)
"
    spinner_stop "ok" "Installed Ludolph on Pi"
fi

# =============================================================================
# Set Up Vault Access (MCP Server)
# =============================================================================

if ! $IS_PI; then
    section "Step 5: Set Up Vault Access"

    info "Your Pi needs a way to read your vault on this Mac."
    info "We'll start a small server that shares your notes securely."
    echo

    # Generate or reuse auth token
    mkdir -p "$LOCAL_DIR"
    if [ -f "$LOCAL_DIR/mcp_token" ]; then
        MCP_AUTH_TOKEN=$(cat "$LOCAL_DIR/mcp_token")
        ok "Using existing auth token"
    else
        spinner_start "Generating auth token..."
        MCP_AUTH_TOKEN=$(openssl rand -hex 32)
        echo "$MCP_AUTH_TOKEN" > "$LOCAL_DIR/mcp_token"
        chmod 600 "$LOCAL_DIR/mcp_token"
        spinner_stop "ok" "Token generated and stored"
    fi

    # Get Mac's IP for Pi to connect to
    # Try Tailscale first, but verify Pi can reach it
    MAC_IP=""
    LOCAL_IP=""
    TAILSCALE_IP=""
    USING_TAILSCALE=false

    # Get local network IP
    LOCAL_IP=$(ipconfig getifaddr en0 2>/dev/null || ipconfig getifaddr en1 2>/dev/null || echo "")

    # Get Tailscale IP if available
    if command -v tailscale &>/dev/null; then
        TAILSCALE_IP=$(tailscale ip -4 2>/dev/null | head -1 || true)
    fi

    # If Mac has Tailscale, check if Pi can use it
    if [ -n "$TAILSCALE_IP" ]; then
        spinner_start "Checking Tailscale connectivity..."
        PI_CAN_REACH_TS=$(ssh -n -o ConnectTimeout=5 "$PI_USER@$PI_HOST" \
            "ping -c 1 -W 2 $TAILSCALE_IP >/dev/null 2>&1 && echo yes || echo no" 2>/dev/null || echo "no")

        if [ "$PI_CAN_REACH_TS" = "yes" ]; then
            spinner_stop "ok" "Tailscale connected"
            MAC_IP="$TAILSCALE_IP"
            USING_TAILSCALE=true
        else
            spinner_stop "warn" "Tailscale not reachable from Pi"

            # Check Pi's Tailscale status
            PI_TS_STATUS=$(ssh -n -o ConnectTimeout=5 "$PI_USER@$PI_HOST" \
                "command -v tailscale >/dev/null && tailscale status 2>&1 | head -1 || echo 'not installed'" 2>/dev/null || echo "unknown")

            echo
            info "Your Mac has Tailscale, but your Pi can't reach it."
            echo

            if echo "$PI_TS_STATUS" | grep -qi "logged out\|stopped"; then
                # Tailscale installed but not running
                info "Tailscale is installed on Pi but not connected."
                echo
                printf "  ${BOLD}Choose an option:${NC}\n"
                echo "  1) Connect Pi to Tailscale (recommended - encrypted)"
                echo "  2) Use local network (unencrypted, home network only)"
                echo
                NETWORK_CHOICE=$(ask "Enter 1 or 2:" "1")

                if [ "$NETWORK_CHOICE" = "1" ]; then
                    echo
                    info "Starting Tailscale on Pi..."
                    info "You may need to authenticate in your browser."
                    echo
                    ssh -t "$PI_USER@$PI_HOST" "sudo tailscale up" || true

                    # Check if it worked
                    sleep 2
                    PI_CAN_REACH_TS=$(ssh -n -o ConnectTimeout=5 "$PI_USER@$PI_HOST" \
                        "ping -c 1 -W 2 $TAILSCALE_IP >/dev/null 2>&1 && echo yes || echo no" 2>/dev/null || echo "no")

                    if [ "$PI_CAN_REACH_TS" = "yes" ]; then
                        ok "Tailscale connected"
                        MAC_IP="$TAILSCALE_IP"
                        USING_TAILSCALE=true
                    else
                        warn "Tailscale connection failed"
                        info "Falling back to local network."
                    fi
                fi

            elif echo "$PI_TS_STATUS" | grep -qi "not installed"; then
                # Tailscale not installed
                printf "  ${BOLD}Choose an option:${NC}\n"
                echo "  1) Install Tailscale on Pi (recommended - encrypted)"
                echo "  2) Use local network (unencrypted, home network only)"
                echo
                NETWORK_CHOICE=$(ask "Enter 1 or 2:" "2")

                if [ "$NETWORK_CHOICE" = "1" ]; then
                    spinner_start "Installing Tailscale on Pi..."
                    ssh -T "$PI_USER@$PI_HOST" "curl -fsSL https://tailscale.com/install.sh | sh" >/dev/null 2>&1 || true
                    spinner_stop "ok" "Tailscale installed"

                    echo
                    info "Starting Tailscale on Pi..."
                    info "You may need to authenticate in your browser."
                    echo
                    ssh -t "$PI_USER@$PI_HOST" "sudo tailscale up" || true

                    # Check if it worked
                    sleep 2
                    PI_CAN_REACH_TS=$(ssh -n -o ConnectTimeout=5 "$PI_USER@$PI_HOST" \
                        "ping -c 1 -W 2 $TAILSCALE_IP >/dev/null 2>&1 && echo yes || echo no" 2>/dev/null || echo "no")

                    if [ "$PI_CAN_REACH_TS" = "yes" ]; then
                        ok "Tailscale connected"
                        MAC_IP="$TAILSCALE_IP"
                        USING_TAILSCALE=true
                    else
                        warn "Tailscale connection failed"
                        info "Falling back to local network."
                    fi
                fi
            else
                # Unknown state
                info "Pi Tailscale status: $PI_TS_STATUS"
                info "Using local network instead."
            fi
            echo
        fi
    fi

    # Fall back to local IP if Tailscale not available/working
    if [ -z "$MAC_IP" ]; then
        if [ -n "$LOCAL_IP" ]; then
            MAC_IP="$LOCAL_IP"
            ok "Using local network: $MAC_IP"
        else
            MAC_IP=$(ask "Enter your Mac's IP address:")
        fi
    fi

    # Summary
    echo
    if $USING_TAILSCALE; then
        ok "Connection: Tailscale (encrypted)"
    else
        warn "Connection: Local network (unencrypted)"
        info "Traffic is plaintext HTTP. Fine for home networks."
    fi

    # Create server files
    spinner_start "Creating vault server..."
    mkdir -p "$LOCAL_DIR/mcp"

    # Write server.py
    cat > "$LOCAL_DIR/mcp/server.py" << 'SERVEREOF'
#!/usr/bin/env python3
"""Ludolph Vault Server - Shares vault with Pi over HTTP."""

import os
import re
from functools import wraps
from pathlib import Path

from flask import Flask, jsonify, request

app = Flask(__name__)

VAULT_PATH = Path(os.environ.get("VAULT_PATH", "~/vault")).expanduser().resolve()
AUTH_TOKEN = os.environ.get("AUTH_TOKEN", "")


def require_auth(f):
    """Decorator to require Bearer token authentication."""
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.headers.get("Authorization", "")
        if auth != f"Bearer {AUTH_TOKEN}":
            return jsonify({"error": "Unauthorized"}), 401
        return f(*args, **kwargs)
    return decorated


def safe_path(relative: str) -> Path | None:
    """Resolve a path safely within the vault, preventing directory traversal."""
    if ".." in relative:
        return None
    # Handle empty path as vault root
    if not relative or relative == ".":
        return VAULT_PATH
    full = (VAULT_PATH / relative).resolve()
    # Ensure path is within vault
    try:
        full.relative_to(VAULT_PATH)
        return full
    except ValueError:
        return None


@app.route("/health")
@require_auth
def health():
    """Health check endpoint."""
    return jsonify({"status": "ok", "vault": str(VAULT_PATH)})


@app.route("/tools")
@require_auth
def tools():
    """Return available tool definitions."""
    return jsonify({
        "tools": [
            {
                "name": "read_file",
                "description": "Read the contents of a file in the vault",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "path": {
                            "type": "string",
                            "description": "Path to the file relative to vault root"
                        }
                    },
                    "required": ["path"]
                }
            },
            {
                "name": "list_dir",
                "description": "List the contents of a directory in the vault",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "path": {
                            "type": "string",
                            "description": "Path to the directory relative to vault root"
                        }
                    },
                    "required": []
                }
            },
            {
                "name": "search",
                "description": "Search for files or content in the vault",
                "input_schema": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Search query (searches file names and content)"
                        },
                        "path": {
                            "type": "string",
                            "description": "Optional subdirectory to search within"
                        }
                    },
                    "required": ["query"]
                }
            }
        ]
    })


@app.route("/tools/call", methods=["POST"])
@require_auth
def call_tool():
    """Execute a tool and return the result."""
    data = request.json or {}
    name = data.get("name", "")
    args = data.get("arguments", {})

    if name == "read_file":
        path = safe_path(args.get("path", ""))
        if not path:
            return jsonify({"content": "", "error": "Invalid path"})
        if not path.exists():
            return jsonify({"content": "", "error": f"File not found: {args.get('path')}"})
        if not path.is_file():
            return jsonify({"content": "", "error": "Path is not a file"})
        try:
            content = path.read_text(encoding="utf-8")
            return jsonify({"content": content, "error": None})
        except Exception as e:
            return jsonify({"content": "", "error": str(e)})

    elif name == "list_dir":
        path = safe_path(args.get("path", ""))
        if not path:
            return jsonify({"content": "", "error": "Invalid path"})
        if not path.exists():
            return jsonify({"content": "", "error": f"Directory not found: {args.get('path', '.')}"})
        if not path.is_dir():
            return jsonify({"content": "", "error": "Path is not a directory"})
        try:
            entries = []
            for entry in sorted(path.iterdir()):
                if entry.name.startswith("."):
                    continue
                kind = "dir" if entry.is_dir() else "file"
                entries.append(f"{kind}: {entry.name}")
            content = "\n".join(entries) if entries else "(empty directory)"
            return jsonify({"content": content, "error": None})
        except Exception as e:
            return jsonify({"content": "", "error": str(e)})

    elif name == "search":
        query = args.get("query", "")
        search_path = safe_path(args.get("path", ""))
        if not search_path:
            search_path = VAULT_PATH
        if not query:
            return jsonify({"content": "", "error": "Query required"})
        try:
            results = []
            pattern = re.compile(re.escape(query), re.IGNORECASE)
            for path in search_path.rglob("*"):
                if path.is_file() and not any(p.startswith(".") for p in path.parts):
                    rel_path = path.relative_to(VAULT_PATH)
                    # Check filename
                    if pattern.search(path.name):
                        results.append(f"file: {rel_path}")
                    # Check content for text files
                    elif path.suffix in (".md", ".txt", ".json", ".yaml", ".yml"):
                        try:
                            content = path.read_text(encoding="utf-8")
                            if pattern.search(content):
                                results.append(f"match: {rel_path}")
                        except Exception:
                            pass
                if len(results) >= 50:
                    break
            content = "\n".join(results) if results else "No matches found"
            return jsonify({"content": content, "error": None})
        except Exception as e:
            return jsonify({"content": "", "error": str(e)})

    return jsonify({"content": "", "error": f"Unknown tool: {name}"})


if __name__ == "__main__":
    if not AUTH_TOKEN:
        print("Warning: AUTH_TOKEN not set - server is unprotected!")
    port = int(os.environ.get("PORT", 8200))
    print(f"Vault: {VAULT_PATH}")
    print(f"Port: {port}")
    app.run(host="0.0.0.0", port=port)
SERVEREOF

    spinner_stop "ok" "Vault server created"

    # Install Flask
    spinner_start "Installing Flask..."
    if pip3 install --user -q flask 2>/dev/null; then
        spinner_stop "ok" "Flask installed"
    elif python3 -m pip install --user -q flask 2>/dev/null; then
        spinner_stop "ok" "Flask installed"
    elif pip3 install --break-system-packages -q flask 2>/dev/null; then
        spinner_stop "ok" "Flask installed"
    else
        spinner_stop "err" "Could not install Flask"
        info "Run: pip3 install flask"
        info "Then re-run this installer"
        exit 1
    fi

    # Choose port (default 8200, but check if in use)
    MCP_PORT=8200
    if lsof -ti :$MCP_PORT >/dev/null 2>&1; then
        # Find an available port
        while lsof -ti :$MCP_PORT >/dev/null 2>&1; do
            MCP_PORT=$((MCP_PORT + 1))
        done
    fi

    # Create launchd plist for auto-start
    spinner_start "Setting up auto-start..."
    PLIST_PATH="$HOME/Library/LaunchAgents/dev.ludolph.mcp.plist"
    mkdir -p "$HOME/Library/LaunchAgents"

    # Get Python user site-packages for PYTHONPATH
    PYTHON_USER_SITE=$(python3 -c 'import site; print(site.getusersitepackages())' 2>/dev/null || echo "$HOME/.local/lib/python3/site-packages")
    PYTHON_PATH=$(which python3)

    cat > "$PLIST_PATH" << PLISTEOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>dev.ludolph.mcp</string>
    <key>ProgramArguments</key>
    <array>
        <string>$PYTHON_PATH</string>
        <string>$LOCAL_DIR/mcp/server.py</string>
    </array>
    <key>WorkingDirectory</key>
    <string>$LOCAL_DIR/mcp</string>
    <key>EnvironmentVariables</key>
    <dict>
        <key>VAULT_PATH</key>
        <string>$VAULT_PATH</string>
        <key>AUTH_TOKEN</key>
        <string>$MCP_AUTH_TOKEN</string>
        <key>PORT</key>
        <string>$MCP_PORT</string>
        <key>PATH</key>
        <string>/usr/local/bin:/usr/bin:/bin:$HOME/.local/bin</string>
        <key>PYTHONPATH</key>
        <string>$PYTHON_USER_SITE</string>
    </dict>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>$LOCAL_DIR/mcp/server.log</string>
    <key>StandardErrorPath</key>
    <string>$LOCAL_DIR/mcp/server.log</string>
</dict>
</plist>
PLISTEOF

    spinner_stop "ok" "Auto-start configured"

    spinner_start "Starting vault server..."

    # Stop any existing ludolph server
    launchctl unload "$PLIST_PATH" 2>/dev/null || true
    pkill -f "ludolph/mcp/server.py" 2>/dev/null || true
    sleep 1

    launchctl load "$PLIST_PATH" 2>/dev/null

    # Wait for server to respond (retry up to 5 times)
    SERVER_OK=false
    for i in 1 2 3 4 5; do
        sleep 1
        if curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $MCP_AUTH_TOKEN" "http://localhost:$MCP_PORT/health" 2>/dev/null | grep -q "200"; then
            SERVER_OK=true
            break
        fi
    done

    if $SERVER_OK; then
        spinner_stop "ok" "Vault server running (port $MCP_PORT, can change later)"
    else
        spinner_stop "err" "Server failed to start"
        echo
        info "Check the error:"
        tail -5 "$LOCAL_DIR/mcp/server.log" 2>/dev/null || echo "  (no log file)"
        echo
        info "Fix the issue and restart:"
        info "  launchctl stop dev.ludolph.mcp"
        info "  launchctl start dev.ludolph.mcp"
        exit 1
    fi
fi

# =============================================================================
# Configure Wake-on-LAN
# =============================================================================

if ! $IS_PI; then
    section "Step 6: Configure Wake-on-LAN"

    info "If your Mac is asleep, the Pi can wake it automatically."
    echo

    # Get Mac's MAC address
    spinner_start "Getting Mac's network address..."
    MAC_ADDRESS=$(ifconfig en0 2>/dev/null | grep ether | awk '{print $2}' || true)
    if [ -z "$MAC_ADDRESS" ]; then
        MAC_ADDRESS=$(ifconfig en1 2>/dev/null | grep ether | awk '{print $2}' || true)
    fi

    if [ -n "$MAC_ADDRESS" ]; then
        spinner_stop "ok" "MAC address: $MAC_ADDRESS"
    else
        spinner_stop "warn" "Could not detect MAC address"
        MAC_ADDRESS=$(ask "Enter your Mac's MAC address (e.g., a4:83:e7:xx:xx:xx):")
    fi

    # Install wakeonlan on Pi
    spinner_start "Installing wakeonlan on Pi..."
    ssh -T "$PI_USER@$PI_HOST" "
command -v wakeonlan >/dev/null 2>&1 || (sudo apt-get update -qq && sudo apt-get install -y -qq wakeonlan >/dev/null 2>&1)
"
    spinner_stop "ok" "Wake-on-LAN ready"

    echo
    info "Note: For Wake-on-LAN to work, you may need to enable it"
    info "in System Settings > Energy Saver > Wake for network access"
    echo
fi

# =============================================================================
# API Credentials
# =============================================================================

section "Step 7: API Keys"

# Check if we have saved credentials
if [ -n "$SAVED_TELEGRAM_TOKEN" ] && [ -n "$SAVED_CLAUDE_KEY" ]; then
    ok "Found saved API keys"
    echo
    if confirm "Use existing API keys?"; then
        TELEGRAM_TOKEN="$SAVED_TELEGRAM_TOKEN"
        TELEGRAM_USER_ID="$SAVED_TELEGRAM_USER"
        CLAUDE_API_KEY="$SAVED_CLAUDE_KEY"
    else
        SAVED_TELEGRAM_TOKEN=""
        SAVED_CLAUDE_KEY=""
    fi
fi

if [ -z "$SAVED_TELEGRAM_TOKEN" ]; then
    info "Ludolph needs two API keys to work:"
    echo
    info "  1. Telegram Bot Token - creates your bot"
    info "     Get one from @BotFather: t.me/BotFather"
    echo
    info "  2. Claude API Key - powers the AI"
    info "     Get one from: console.anthropic.com"
    echo

    pause

    TELEGRAM_TOKEN=$(ask_secret "Telegram Bot Token:")
    [ -z "$TELEGRAM_TOKEN" ] && { err "Token required"; exit 1; }

    # Validate token and show bot info
    spinner_start "Validating bot token..."
    BOT_RESPONSE=$(curl -s "https://api.telegram.org/bot$TELEGRAM_TOKEN/getMe" 2>/dev/null || echo '{"ok":false}')

    if echo "$BOT_RESPONSE" | grep -q '"ok":true'; then
        BOT_NAME=$(echo "$BOT_RESPONSE" | grep -o '"first_name":"[^"]*"' | cut -d'"' -f4)
        BOT_USERNAME=$(echo "$BOT_RESPONSE" | grep -o '"username":"[^"]*"' | cut -d'"' -f4)
        spinner_stop "ok" "Bot: $BOT_NAME (@$BOT_USERNAME)"
    else
        spinner_stop "err" "Invalid bot token"
        err "Could not validate token with Telegram"
        exit 1
    fi

    echo
    TELEGRAM_USER_ID=$(ask "Your Telegram User ID (get from @userinfobot):" "$SAVED_TELEGRAM_USER")
    [ -z "$TELEGRAM_USER_ID" ] && { err "User ID required"; exit 1; }

    echo
    CLAUDE_API_KEY=$(ask_secret "Claude API Key:")
    [ -z "$CLAUDE_API_KEY" ] && { err "API key required"; exit 1; }
fi

# =============================================================================
# Configure and Start Bot
# =============================================================================

section "Step 8: Starting Ludolph"

# Pi config includes MCP connection details
PI_CONFIG="[telegram]
bot_token = \"$TELEGRAM_TOKEN\"
allowed_users = [$TELEGRAM_USER_ID]

[claude]
api_key = \"$CLAUDE_API_KEY\"
model = \"claude-sonnet-4-20250514\"

[mcp]
url = \"http://$MAC_IP:$MCP_PORT\"
auth_token = \"$MCP_AUTH_TOKEN\"
mac_address = \"$MAC_ADDRESS\"
"

if $IS_PI; then
    spinner_start "Saving configuration..."
    mkdir -p "$LOCAL_DIR"
    echo "$PI_CONFIG" > "$LOCAL_DIR/config.toml"
    spinner_stop "ok" "Configuration saved"

    spinner_start "Setting up bot service..."

    # Stop any existing process
    pkill -f "ludolph/bin/lu" 2>/dev/null || true

    # Create systemd user directory
    mkdir -p ~/.config/systemd/user

    # Create service file
    cat > ~/.config/systemd/user/ludolph.service << 'EOF'
[Unit]
Description=Ludolph Telegram Bot
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=%h/.ludolph/bin/lu
Restart=always
RestartSec=5
StandardOutput=append:%h/.ludolph/ludolph.log
StandardError=append:%h/.ludolph/ludolph.log

[Install]
WantedBy=default.target
EOF

    # Enable lingering so service runs without login
    loginctl enable-linger "$USER" 2>/dev/null || true

    # Reload and start service
    systemctl --user daemon-reload
    systemctl --user enable ludolph.service
    systemctl --user restart ludolph.service

    spinner_stop "ok" "Bot service installed"

    sleep 2
    if systemctl --user is-active ludolph.service >/dev/null 2>&1; then
        ok "Bot is running (auto-restarts on crash)"
    else
        warn "Check: systemctl --user status ludolph.service"
    fi
else
    spinner_start "Saving configuration on Pi..."
    # Write config directly (heredoc with quotes prevents expansion)
    echo "$PI_CONFIG" | ssh -T "$PI_USER@$PI_HOST" "mkdir -p ~/.ludolph && cat > ~/.ludolph/config.toml"
    spinner_stop "ok" "Pi configuration saved"

    # Mac config includes vault path and Pi connection info
    spinner_start "Saving configuration on Mac..."
    mkdir -p "$LOCAL_DIR"
    cat > "$LOCAL_DIR/config.toml" <<EOF
[telegram]
bot_token = "$TELEGRAM_TOKEN"
allowed_users = [$TELEGRAM_USER_ID]

[claude]
api_key = "$CLAUDE_API_KEY"
model = "claude-sonnet-4-20250514"

[vault]
path = "$VAULT_PATH"

[pi]
host = "$PI_HOST"
user = "$PI_USER"
EOF
    spinner_stop "ok" "Mac configuration saved"

    spinner_start "Setting up bot service on Pi..."

    # Service file content (defined here to avoid heredoc stdin issues with curl|bash)
    SERVICE_CONTENT='[Unit]
Description=Ludolph Telegram Bot
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=%h/.ludolph/bin/lu
Restart=always
RestartSec=5
StandardOutput=append:%h/.ludolph/ludolph.log
StandardError=append:%h/.ludolph/ludolph.log

[Install]
WantedBy=default.target'

    # Create systemd service on Pi using inline commands (no heredocs)
    ssh -T "$PI_USER@$PI_HOST" "
pkill -f 'ludolph/bin/lu' 2>/dev/null || true;
mkdir -p ~/.config/systemd/user;
printf '%s\n' '$SERVICE_CONTENT' > ~/.config/systemd/user/ludolph.service;
loginctl enable-linger \$USER 2>/dev/null || true;
systemctl --user daemon-reload;
systemctl --user enable ludolph.service;
systemctl --user restart ludolph.service
"

    spinner_stop "ok" "Bot service installed"

    # Check if service is running
    sleep 2
    BOT_STATUS=$(ssh -n -o ConnectTimeout=5 "$PI_USER@$PI_HOST" \
        "systemctl --user is-active ludolph.service 2>/dev/null" || echo "unknown")

    if [ "$BOT_STATUS" = "active" ]; then
        ok "Bot is running (auto-restarts on crash)"
    else
        warn "Bot service may not have started"
        info "Check with: ssh $PI_USER@$PI_HOST 'systemctl --user status ludolph.service'"
    fi

    # Verify MCP connection from Pi
    spinner_start "Verifying MCP connection..."
    MCP_TEST=$(timeout 10 ssh -n -o ConnectTimeout=5 "$PI_USER@$PI_HOST" \
        "curl -s -m 5 -H 'Authorization: Bearer $MCP_AUTH_TOKEN' 'http://$MAC_IP:$MCP_PORT/health' 2>/dev/null" \
        || echo "failed")

    if echo "$MCP_TEST" | grep -q '"status":"ok"'; then
        spinner_stop "ok" "MCP connection verified"
    else
        spinner_stop "err" "MCP connection failed"
        echo
        err "Pi cannot reach the vault server on your Mac"
        echo
        info "The server is running at http://$MAC_IP:$MCP_PORT"
        info "but the Pi cannot connect to it."
        echo
        info "Possible causes:"
        info "  - Firewall blocking port $MCP_PORT"
        info "  - Pi and Mac on different networks"
        if [ -n "$TAILSCALE_IP" ] && ! $USING_TAILSCALE; then
            info "  - Tailscale not running on Pi (run: sudo tailscale up)"
        fi
        echo
        info "To test manually from your Pi:"
        info "  curl -H 'Authorization: Bearer \$(cat ~/.ludolph/mcp_token)' http://$MAC_IP:$MCP_PORT/health"
        echo
    fi
fi

# =============================================================================
# Done
# =============================================================================

section "Setup Complete!"

BOT_INFO=$(curl -s "https://api.telegram.org/bot$TELEGRAM_TOKEN/getMe" 2>/dev/null || true)
BOT_USERNAME=$(echo "$BOT_INFO" | grep -o '"username":"[^"]*"' | cut -d'"' -f4 || echo "your bot")

echo
printf "  Open Telegram and message ${CYAN}@%s${NC}\n" "$BOT_USERNAME"
echo
if ! $IS_PI; then
    ok "Vault server running on your Mac"
    ok "Bot running on your Pi"
    echo
fi
info "Everything is connected and ready."
echo
rule
echo
info "Test it now - send /poke in Telegram"
echo
rule
echo
info "Helpful commands:"
if $IS_PI; then
    info "  lu          Start the bot"
    info "  lu status   Check bot status"
else
    info "  ssh $PI_USER@$PI_HOST   Connect to your Pi"
    echo
    info "Vault server commands:"
    info "  launchctl stop dev.ludolph.mcp     Stop server"
    info "  launchctl start dev.ludolph.mcp    Start server"
    info "  tail -f ~/.ludolph/mcp/server.log  View logs"
fi
echo
