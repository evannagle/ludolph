#!/usr/bin/env bash
set -euo pipefail

# Ludolph Mac-First Installer
# Usage: curl -sSL https://ludolph.dev/install | bash

REPO="evannagle/ludolph"
LOCAL_DIR="${LUDOLPH_DIR:-$HOME/.ludolph}"
VERSION="${LUDOLPH_VERSION:-}"

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
DIM='\033[0;90m'
CYAN='\033[0;36m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m'

# Output helpers
ok() { printf "  ${GREEN}[•ok]${NC} %s\n" "$1"; }
err() { printf "  ${RED}[•!!]${NC} %s\n" "$1"; }
warn() { printf "  ${YELLOW}[•--]${NC} %s\n" "$1"; }
info() { printf "  ${DIM}%s${NC}\n" "$1"; }

# Bouncing ball spinner (matches Rust version)
SPINNER_PID=""

spinner_start() {
    local msg="$1"
    (
        local frames=("•  " " • " "  •" " • ")
        local i=0
        while true; do
            printf "\r  [%s] %s" "${frames[$i]}" "$msg"
            i=$(( (i + 1) % 4 ))
            sleep 0.2
        done
    ) &
    SPINNER_PID=$!
}

spinner_stop() {
    local status="$1"
    local msg="$2"
    [ -n "$SPINNER_PID" ] && kill "$SPINNER_PID" 2>/dev/null
    wait "$SPINNER_PID" 2>/dev/null || true
    SPINNER_PID=""
    printf "\r\033[K"  # Clear line
    if [ "$status" = "ok" ]; then
        ok "$msg"
    elif [ "$status" = "err" ]; then
        err "$msg"
    else
        warn "$msg"
    fi
}

# Section header with blank lines
section() {
    echo
    printf "${BOLD}%s${NC}\n" "$1"
    echo
}

# Horizontal rule
rule() {
    printf "  ${DIM}────────────────────────────────────────${NC}\n"
}

# Wait for user to press Enter
pause() {
    printf "\n  ${DIM}Press Enter to continue...${NC}"
    read -r
    echo
}

# Ask yes/no, returns 0 for yes
confirm() {
    local response
    printf "  %s ${DIM}[Y/n]${NC} " "$1"
    read -r response
    case "$response" in
        [nN]*) return 1 ;;
        *) return 0 ;;
    esac
}

# Prompt for text input
ask() {
    local prompt="$1"
    local default="${2:-}"
    local result

    if [ -n "$default" ]; then
        printf "  %s\n" "$prompt" >&2
        printf "  ${DIM}Default: %s${NC}\n" "$default" >&2
    else
        printf "  %s\n" "$prompt" >&2
    fi
    printf "  > " >&2
    read -r result
    echo >&2

    # Trim whitespace
    result="${result#"${result%%[![:space:]]*}"}"
    result="${result%"${result##*[![:space:]]}"}"

    [ -z "$result" ] && result="$default"
    printf '%s' "$result"
}

# Prompt for secret input (hidden)
ask_secret() {
    local prompt="$1"

    printf "  %s\n" "$prompt" >&2
    printf "  > " >&2
    read -rs result
    echo >&2

    # Trim whitespace
    result="${result#"${result%%[![:space:]]*}"}"
    result="${result%"${result##*[![:space:]]}"}"

    printf '%s' "$result"
}

# =============================================================================
# Welcome
# =============================================================================

clear
echo
printf "${BOLD}Ludolph Installer${NC}\n"
echo
info "A real brain for your second brain."
info "Talk to your vault, from anywhere, anytime."
echo
rule
echo
info "This installer will:"
info "  1. Find your Obsidian vault"
info "  2. Set up sync to your Raspberry Pi"
info "  3. Configure the Telegram bot"
echo

if ! confirm "Ready to begin?"; then
    echo
    info "Run this installer again when you're ready."
    echo
    exit 0
fi

# =============================================================================
# Platform Detection
# =============================================================================

section "Step 1: Checking Your System"

OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
ARCH="$(uname -m)"

case "$ARCH" in
    x86_64) ARCH="x86_64" ;;
    aarch64|arm64) ARCH="aarch64" ;;
    *)
        err "Unsupported architecture: $ARCH"
        exit 1
        ;;
esac

IS_MAC=false
IS_PI=false

case "$OS" in
    darwin)
        IS_MAC=true
        TARGET="${ARCH}-apple-darwin"
        ok "macOS detected"
        ;;
    linux)
        TARGET="${ARCH}-unknown-linux-gnu"
        if [ "$ARCH" = "aarch64" ]; then
            IS_PI=true
            ok "Raspberry Pi detected"
        else
            ok "Linux detected"
        fi
        ;;
    *)
        err "Unsupported OS: $OS"
        exit 1
        ;;
esac

# =============================================================================
# Find Vault
# =============================================================================

section "Step 2: Finding Your Vault"

info "Looking for Obsidian vaults..."
echo

VAULT_PATH=""
VAULT_CANDIDATES=(
    "$HOME/Documents/Obsidian"
    "$HOME/Obsidian"
    "$HOME/Documents/vault"
    "$HOME/vault"
    "$HOME/Documents/Notes"
    "$HOME/Notes"
    "$HOME/Vaults"
)

# Check for vaults with .obsidian folder
for candidate in "${VAULT_CANDIDATES[@]}"; do
    if [ -d "$candidate/.obsidian" ]; then
        VAULT_PATH="$candidate"
        break
    fi
done

# Also check inside common parent folders
for parent in "$HOME/Vaults" "$HOME/Documents/Vaults" "$HOME/Documents/Obsidian"; do
    if [ -d "$parent" ]; then
        while IFS= read -r -d '' vault; do
            if [ -d "$vault/.obsidian" ]; then
                VAULT_PATH="$vault"
                break 2
            fi
        done < <(find "$parent" -maxdepth 2 -type d -name ".obsidian" -print0 2>/dev/null)
    fi
done

if [ -n "$VAULT_PATH" ]; then
    ok "Found vault: $VAULT_PATH"
    echo
    if ! confirm "Use this vault?"; then
        VAULT_PATH=""
    fi
fi

if [ -z "$VAULT_PATH" ]; then
    echo
    VAULT_PATH=$(ask "Enter the path to your Obsidian vault:" "$HOME/vault")
fi

# Expand tilde
VAULT_PATH="${VAULT_PATH/#\~/$HOME}"

# Validate or create
if [ ! -d "$VAULT_PATH" ]; then
    echo
    warn "Folder does not exist: $VAULT_PATH"
    if confirm "Create it?"; then
        mkdir -p "$VAULT_PATH/.obsidian"
        ok "Created vault folder"
    else
        err "Cannot continue without a vault folder"
        exit 1
    fi
else
    ok "Vault confirmed: $VAULT_PATH"
fi

# =============================================================================
# Privacy Check
# =============================================================================

section "Step 3: Privacy Check"

info "Your vault will be synced to your Pi via GitHub."
info "This step checks for files you might want to exclude."
echo

if confirm "Scan for sensitive files? (API keys, passwords, etc.)"; then
    echo
    spinner_start "Scanning for sensitive files..."

    PRIVACY_FILES=()

    # Check for sensitive filenames
    while IFS= read -r -d '' file; do
        filename=$(basename "$file" | tr '[:upper:]' '[:lower:]')
        case "$filename" in
            .env*|*credential*|*secret*|*password*|*apikey*|*api_key*)
                rel="${file#$VAULT_PATH/}"
                PRIVACY_FILES+=("$rel")
                ;;
        esac
    done < <(find "$VAULT_PATH" -type f \( -name "*.md" -o -name "*.txt" -o -name ".env*" -o -name "*.json" \) -print0 2>/dev/null || true)

    # Check file contents for API key patterns
    while IFS= read -r -d '' file; do
        if [ -f "$file" ] && [ "$(wc -c < "$file" 2>/dev/null)" -lt 1000000 ]; then
            if grep -qE 'sk-[a-zA-Z0-9]{20,}' "$file" 2>/dev/null; then
                rel="${file#$VAULT_PATH/}"
                [[ ! " ${PRIVACY_FILES[*]} " =~ " ${rel} " ]] && PRIVACY_FILES+=("$rel")
            fi
        fi
    done < <(find "$VAULT_PATH" -type f -name "*.md" -print0 2>/dev/null || true)

    if [ ${#PRIVACY_FILES[@]} -gt 0 ]; then
        spinner_stop "err" "Found ${#PRIVACY_FILES[@]} potentially sensitive file(s):"
        echo

        EXCLUDED_FILES=()
        for f in "${PRIVACY_FILES[@]}"; do
            printf "    ${RED}• %s${NC}\n" "$f"
            if confirm "      Exclude this file?"; then
                EXCLUDED_FILES+=("$f")
            fi
            echo
        done

        if [ ${#EXCLUDED_FILES[@]} -gt 0 ]; then
            ok "Will exclude ${#EXCLUDED_FILES[@]} file(s)"
            PRIVACY_FILES=("${EXCLUDED_FILES[@]}")
            EXCLUDE_PRIVACY=true
        else
            ok "No files excluded"
            EXCLUDE_PRIVACY=false
        fi
    else
        spinner_stop "ok" "No sensitive files found"
        EXCLUDE_PRIVACY=false
    fi
else
    echo
    ok "Skipping privacy scan"
    EXCLUDE_PRIVACY=false
fi

# =============================================================================
# Git Setup
# =============================================================================

section "Step 4: Setting Up Sync"

info "Ludolph uses Git + GitHub for two-way sync."
info "Your edits sync to Pi, Claude's edits sync back."
echo

cd "$VAULT_PATH"

IS_GIT_REPO=false
HAS_REMOTE=false
REMOTE_URL=""
GIT_ROOT=""
VAULT_SUBDIR=""

# Check if we're inside a git repo (even if not at root)
if git rev-parse --is-inside-work-tree &>/dev/null; then
    IS_GIT_REPO=true
    GIT_ROOT=$(git rev-parse --show-toplevel)
    REMOTE_URL=$(git remote get-url origin 2>/dev/null || true)
    [ -n "$REMOTE_URL" ] && HAS_REMOTE=true

    # Check if vault is a subdirectory of the repo
    if [ "$GIT_ROOT" != "$VAULT_PATH" ]; then
        VAULT_SUBDIR="${VAULT_PATH#$GIT_ROOT/}"
        ok "Git repo: $GIT_ROOT"
        ok "Vault path: $VAULT_SUBDIR"
    fi
fi

if $HAS_REMOTE; then
    ok "Remote: $REMOTE_URL"
    spinner_start "Verifying GitHub access..."
    if git ls-remote origin &>/dev/null; then
        spinner_stop "ok" "GitHub access confirmed"
    else
        spinner_stop "err" "Cannot access repository"
        info "Check your SSH keys: ssh -T git@github.com"
        exit 1
    fi
else
    if ! confirm "Set up GitHub sync?"; then
        err "GitHub sync is required for Ludolph to work"
        exit 1
    fi

    echo

    # Initialize git if needed
    if ! $IS_GIT_REPO; then
        info "Initializing version control..."
        git init -q
        GIT_ROOT="$VAULT_PATH"
        ok "Git initialized"
    fi

    # Create .gitignore (at git root or vault path)
    GITIGNORE_PATH="$VAULT_PATH/.gitignore"
    [ -n "$VAULT_SUBDIR" ] && GITIGNORE_PATH="$GIT_ROOT/.gitignore"

    GITIGNORE="# Obsidian workspace
.obsidian/workspace.json
.obsidian/workspace-mobile.json
.obsidian/workspace.json.bak
.trash/
.DS_Store
"
    if [ "$EXCLUDE_PRIVACY" = true ] && [ ${#PRIVACY_FILES[@]} -gt 0 ]; then
        GITIGNORE+="
# Excluded by Ludolph installer
"
        for f in "${PRIVACY_FILES[@]}"; do
            # Prefix with vault subdir if needed
            [ -n "$VAULT_SUBDIR" ] && f="$VAULT_SUBDIR/$f"
            GITIGNORE+="$f
"
        done
    fi

    # Append to existing .gitignore or create new
    if [ -f "$GITIGNORE_PATH" ]; then
        echo "" >> "$GITIGNORE_PATH"
        echo "# Added by Ludolph installer" >> "$GITIGNORE_PATH"
        echo "$GITIGNORE" >> "$GITIGNORE_PATH"
        ok "Updated .gitignore"
    else
        echo "$GITIGNORE" > "$GITIGNORE_PATH"
        ok "Created .gitignore"
    fi

    # Try gh CLI
    if command -v gh &>/dev/null; then
        echo
        VAULT_NAME=$(basename "$VAULT_PATH" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')
        REPO_NAME=$(ask "Repository name:" "$VAULT_NAME")

        echo
        info "Creating private repository..."
        if gh repo create "$REPO_NAME" --private --source=. --remote=origin 2>/dev/null; then
            ok "Created: github.com/$(gh api user -q .login)/$REPO_NAME"
            HAS_REMOTE=true
        else
            warn "Could not create automatically"
            info "You may need to run: gh auth login"
        fi
    fi

    # Manual fallback
    if ! $HAS_REMOTE; then
        echo
        info "Create a new private repository at github.com/new"
        info "Then paste the SSH URL (git@github.com:...)"
        echo
        REMOTE_URL=$(ask "Repository URL:")

        if [ -z "$REMOTE_URL" ]; then
            err "Repository URL required"
            exit 1
        fi

        git remote add origin "$REMOTE_URL" 2>/dev/null || git remote set-url origin "$REMOTE_URL"
        ok "Remote configured"
        HAS_REMOTE=true
    fi

    # Initial commit and push
    echo
    info "Pushing to GitHub..."
    git add -A
    git commit -m "Initial commit" -q 2>/dev/null || true
    BRANCH=$(git branch --show-current 2>/dev/null || echo "main")

    if git push -u origin "$BRANCH" 2>/dev/null; then
        ok "Vault pushed to GitHub"
    else
        err "Push failed. Check your SSH keys: ssh -T git@github.com"
        exit 1
    fi
fi

# =============================================================================
# Connect to Pi
# =============================================================================

section "Step 5: Connecting to Your Pi"

if $IS_PI; then
    ok "Running on Pi - no remote connection needed"
    PI_HOST="localhost"
    PI_USER="$USER"
else
    info "Make sure your Pi is:"
    info "  - Powered on and connected to the network"
    info "  - SSH enabled"
    info "  - Accessible via Tailscale (recommended) or local network"
    echo

    # Try to detect Pi
    PI_DETECTED=""
    for host in "pi" "raspberrypi" "pi.local" "raspberrypi.local"; do
        if ping -c 1 -W 1 "$host" &>/dev/null 2>&1; then
            PI_DETECTED="$host"
            break
        fi
    done

    PI_HOST=$(ask "Pi hostname or IP:" "${PI_DETECTED:-pi.local}")
    PI_USER=$(ask "SSH username:" "pi")

    spinner_start "Connecting to $PI_USER@$PI_HOST..."

    if ssh -o ConnectTimeout=5 -o BatchMode=yes "$PI_USER@$PI_HOST" "echo ok" &>/dev/null; then
        spinner_stop "ok" "Connected to $PI_USER@$PI_HOST"
    else
        spinner_stop "err" "Could not connect to $PI_USER@$PI_HOST"
        echo
        info "Troubleshooting:"
        info "  1. Verify Pi is on: ping $PI_HOST"
        info "  2. Set up SSH keys: ssh-copy-id $PI_USER@$PI_HOST"
        info "  3. Test manually: ssh $PI_USER@$PI_HOST"
        echo
        exit 1
    fi
fi

# =============================================================================
# Deploy to Pi
# =============================================================================

section "Step 6: Installing on Pi"

# Get version
if [ -z "$VERSION" ]; then
    spinner_start "Fetching latest version..."
    VERSION=$(curl -sSL "https://api.github.com/repos/$REPO/releases/latest" 2>/dev/null | grep '"tag_name"' | cut -d'"' -f4 || true)
    if [ -z "$VERSION" ]; then
        spinner_stop "err" "Could not fetch version"
        exit 1
    fi
    spinner_stop "ok" "Version: $VERSION"
else
    ok "Version: $VERSION"
fi

if $IS_PI; then
    # Local install
    PI_INSTALL_DIR="$LOCAL_DIR/bin"
    PI_VAULT_PATH="$VAULT_PATH"

    mkdir -p "$PI_INSTALL_DIR"
    info "Downloading..."
    DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/lu-$TARGET"
    curl -fsSL "$DOWNLOAD_URL" -o "$PI_INSTALL_DIR/lu" 2>/dev/null
    chmod +x "$PI_INSTALL_DIR/lu"
    ok "Installed lu binary"
else
    # Remote install
    PI_TARGET="aarch64-unknown-linux-gnu"
    PI_DOWNLOAD_URL="https://github.com/$REPO/releases/download/$VERSION/lu-$PI_TARGET"
    REMOTE_URL=$(git remote get-url origin 2>/dev/null || true)

    spinner_start "Installing Ludolph on Pi..."
    ssh "$PI_USER@$PI_HOST" bash -s <<EOF
set -e
mkdir -p ~/.ludolph/bin
curl -fsSL "$PI_DOWNLOAD_URL" -o ~/.ludolph/bin/lu 2>/dev/null
chmod +x ~/.ludolph/bin/lu
grep -q '.ludolph/bin' ~/.bashrc 2>/dev/null || echo 'export PATH="\$HOME/.ludolph/bin:\$PATH"' >> ~/.bashrc
grep -q '.ludolph/bin' ~/.profile 2>/dev/null || echo 'export PATH="\$HOME/.ludolph/bin:\$PATH"' >> ~/.profile
EOF
    spinner_stop "ok" "Installed lu binary"

    # Clone repo to Pi
    [ -n "$VAULT_SUBDIR" ] && PI_VAULT_PATH="~/repo/$VAULT_SUBDIR" || PI_VAULT_PATH="~/repo"

    spinner_start "Syncing repository to Pi..."
    ssh "$PI_USER@$PI_HOST" bash -s <<EOF
set -e
if [ -d ~/repo ]; then
    cd ~/repo && git pull origin 2>/dev/null || true
else
    git clone "$REMOTE_URL" ~/repo 2>/dev/null
fi
# Configure git for commits
git config --global user.email "ludolph@pi.local" 2>/dev/null || true
git config --global user.name "Ludolph" 2>/dev/null || true
EOF
    spinner_stop "ok" "Repository synced"

    # Set up bidirectional sync
    spinner_start "Setting up auto-sync..."
    ssh "$PI_USER@$PI_HOST" bash -s <<'EOF'
(crontab -l 2>/dev/null | grep -v 'ludolph sync' || true) | crontab -
# Pull changes from Mac, then push any local changes
(crontab -l 2>/dev/null || true; echo "*/5 * * * * cd ~/repo && git pull origin 2>/dev/null && git add -A && git diff --quiet --cached || git commit -m 'Auto-sync from Pi' && git push origin 2>/dev/null # ludolph sync") | crontab -
EOF
    spinner_stop "ok" "Auto-sync enabled (every 5 minutes)"
fi

# =============================================================================
# API Credentials
# =============================================================================

section "Step 7: API Keys"

info "Ludolph needs two API keys to work:"
echo
info "  1. Telegram Bot Token - creates your bot"
info "     Get one from @BotFather: t.me/BotFather"
echo
info "  2. Claude API Key - powers the AI"
info "     Get one from: console.anthropic.com"
echo

pause

TELEGRAM_TOKEN=$(ask_secret "Telegram Bot Token:")
[ -z "$TELEGRAM_TOKEN" ] && { err "Token required"; exit 1; }

echo
TELEGRAM_USER_ID=$(ask "Your Telegram User ID (get from @userinfobot):")
[ -z "$TELEGRAM_USER_ID" ] && { err "User ID required"; exit 1; }

echo
CLAUDE_API_KEY=$(ask_secret "Claude API Key:")
[ -z "$CLAUDE_API_KEY" ] && { err "API key required"; exit 1; }

# =============================================================================
# Configure and Start
# =============================================================================

section "Step 8: Starting Ludolph"

CONFIG="[telegram]
bot_token = \"$TELEGRAM_TOKEN\"
allowed_users = [$TELEGRAM_USER_ID]

[claude]
api_key = \"$CLAUDE_API_KEY\"
model = \"claude-sonnet-4-20250514\"

[vault]
path = \"$PI_VAULT_PATH\"
"

if $IS_PI; then
    spinner_start "Saving configuration..."
    mkdir -p "$LOCAL_DIR"
    echo "$CONFIG" > "$LOCAL_DIR/config.toml"
    spinner_stop "ok" "Configuration saved"

    spinner_start "Starting bot..."
    nohup "$LOCAL_DIR/bin/lu" > "$LOCAL_DIR/ludolph.log" 2>&1 &
    sleep 2
    if pgrep -f 'ludolph/bin/lu' >/dev/null; then
        spinner_stop "ok" "Bot is running"
    else
        spinner_stop "warn" "Check ~/.ludolph/ludolph.log"
    fi
else
    spinner_start "Saving configuration..."
    ssh "$PI_USER@$PI_HOST" bash -s <<EOF
mkdir -p ~/.ludolph
cat > ~/.ludolph/config.toml << 'CONFIGEOF'
$CONFIG
CONFIGEOF
EOF
    # Save local config too
    mkdir -p "$LOCAL_DIR"
    cat > "$LOCAL_DIR/config.toml" <<EOF
[telegram]
bot_token = "$TELEGRAM_TOKEN"
allowed_users = [$TELEGRAM_USER_ID]

[claude]
api_key = "$CLAUDE_API_KEY"
model = "claude-sonnet-4-20250514"

[vault]
path = "$VAULT_PATH"

[pi]
host = "$PI_HOST"
user = "$PI_USER"
EOF
    spinner_stop "ok" "Configuration saved"

    spinner_start "Starting bot on Pi..."
    BOT_STARTED=$(ssh "$PI_USER@$PI_HOST" bash -s <<'EOF'
pkill -f 'ludolph/bin/lu' 2>/dev/null || true
export PATH="$HOME/.ludolph/bin:$PATH"
nohup ~/.ludolph/bin/lu > ~/.ludolph/ludolph.log 2>&1 &
sleep 2
pgrep -f 'ludolph/bin/lu' >/dev/null && echo "running"
EOF
)
    if [ "$BOT_STARTED" = "running" ]; then
        spinner_stop "ok" "Bot is running"
    else
        spinner_stop "warn" "Bot may not have started"
    fi
    ok "Bot is running"
fi

# =============================================================================
# Done
# =============================================================================

section "Setup Complete!"

# Get bot username
BOT_INFO=$(curl -s "https://api.telegram.org/bot$TELEGRAM_TOKEN/getMe" 2>/dev/null || true)
BOT_USERNAME=$(echo "$BOT_INFO" | grep -o '"username":"[^"]*"' | cut -d'"' -f4 || echo "your bot")

echo
printf "  Open Telegram and message ${CYAN}@%s${NC}\n" "$BOT_USERNAME"
echo
info "Your vault is ready to talk."
echo
rule
echo
info "Helpful commands:"
if $IS_PI; then
    info "  lu          Start the bot"
    info "  lu status   Check bot status"
else
    info "  ssh $PI_USER@$PI_HOST   Connect to your Pi"
fi
info "  git commit  Save vault changes (in your vault folder)"
echo
